%!TEX root = main.tex

We have implemented the decision procedure presented in the preceding section based on the recent string constraint solver \ostrich~\cite{CHL+19}, resulting in a new solver \ostrich+. \ostrich\ is  written in Scala and based on the SMT solver Princess \cite{princess08}. \ostrich+ reuses the parser of Princess, but replaces the NFAs from \ostrich\ with CEFAs. Correspondingly, in \ostrich+, the pre-image  computation for concatenation, $\replaceall$, $\reverse$, and finite transducers is reimplemented, and a new pre-image operator for $\substring$ is added. \ostrich+ also implements CEFA constructions for $\length$ and $\indexof$.  \iftoggle{full}{More details can be found in Appendix~\ref{appendix:impl}}{More details can be found in the full version~\cite{atva20-full}}.

We have compared {\ostrich}+ with some of the state-of-the-art solvers on a wide range of benchmarks.  
We  discuss the benchmarks in Section~\ref{sec:bench} and %describe the details of the experiments as well as 
present the experimental results in Section~\ref{sec:exp-res}.
%and SLENT \cite{WC+18}. 


\vspace{-3mm}
\subsection{Benchmarks}\label{sec:bench}
Our evaluation focuses on problems that combine string with integer constraints.  To this end, we consider the following four sets of
benchmarks, all in SMT-LIB~2 format.

%\paragraph*{
\smallskip
\noindent \transducerbench+
is derived from the {\transducerbench} benchmark suite of {\ostrich}
\cite{CHL+19}.  The {\transducerbench} suite involves seven
transducers: toUpper (replacing all lowercase letters with their
uppercase ones) and its dual toLower, htmlEscape   and
its dual htmlUnescape, escapeString, addslashes, and trim. 
%
These transducers are
collected from Stranger \cite{YABI14} and SLOTH
\cite{HJLRV18}. Initially none of the benchmarks involved integers. In
{\transducerbench+}, we encode four security-relevant properties of
transducers~\cite{BEK}, with the help of the functions~$\charat$ and
$\length$:
\begin{itemize}
\item idempotence: given $\NFT$, whether
  $\forall x.\ \NFT(\NFT(x)) = \NFT(x)$;
\item duality: given $\NFT_1$ and
  $\NFT_2$, whether $\forall x.\ \NFT_2(\NFT_1(x)) = x$;
\item commutativity: given $\NFT_1$ and $\NFT_2$, whether
  $\forall x.\ \NFT_2(\NFT_1(x)) = \NFT_1(\NFT_2(x))$;
\item equivalence: given $\NFT_1$ and $\NFT_2$, whether
  $\forall x.\ \NFT_1(x) = \NFT_2(x)$.
\end{itemize}

%
%\footnote{These problems have been investigated for transducers in \cite{BEK}.} 
%into the path feasibility of {\slint} programs. 
For instance, we encode the non-idempotence of $\NFT$ into the path feasibility of the {\slint} program $y:=\NFT(x); z:=\NFT(y); S_{y \neq z}$, where $y$ and $z$ are two fresh string variables, and $S_{y \neq z}$ is the {\slint} program encoding $y \neq z$ (see 
\iftoggle{full}{Appendix~\ref{appendix:slint-prog-ineq} for the details}{the full version \cite{atva20-full} for the details}
). We also include in {\transducerbench+} three instances %generated from the running example in Section~\ref{exmp:running}, 
generated from a program to sanitize URLs against XSS attacks (see \iftoggle{full}{Appendix~\ref{exmp:running} for the details}{the full version \cite{atva20-full} for the details}), 
where $\NFT_{\rm trim}$ is used. 
In total, we obtain 94 instances for the {\transducerbench+} suite. 

\smallskip
\noindent{\slogbench} is adapted from the SLOG benchmark suite%used by the SLOG tool
~\cite{fang-yu-circuits}, containing 3,511~instances about strings only.
%The SLOG are derived from the security analysis of real web applications and contain 1-211 string variables (average 6.5) and 1-182 atomic formula (average 5.8).
%Note that the SLOG benchmark suite addresses strings only. 
We  obtain  {\slogbench}  by choosing a string variable $x$ for each instance,
%SLOG benchmark instance ,
%\footnote{A string variable is called the output variable if it occurs in the left-hand side of an assignment statement, but does not appear in the right-hand sides of the assignment statements.} 
%say $x$, 
and adding the statement $\ASSERT{\length(x) < 2\ \indexof_{a}(x, 0)}$ for some $a \in \Sigma$.
% and $c \in \Nat$ with $c > 1$.
As in \cite{CHL+19}, we  split  {\slogbench}  into  \slogbenchr\ and \slogbenchra,  comprising 3,391 and 120 instances respectively. In addition to %the aforementioned 
the $\indexof$ and $\length$ functions, the benchmarks use regular constraints and concatenation;  {\slogbenchr} also contains the $\replace$ function (replacing the first occurrence), while {\slogbenchra}  uses the $\replaceall$ function (replacing all occurrences).

\smallskip
\noindent \pyexbench~\cite{ReynoldsWBBLT17} 
contains 25,421 instances  derived by the PyEx tool, a symbolic execution engine for Python programs. The {\pyexbench} suite was generated by the CVC4 group from four popular Python packages: httplib2, pip, pymongo, and requests. These instances use regular constraints, concatenation, $\length$, $\substring$, and $\indexof$ functions. Following \cite{ReynoldsWBBLT17}, the {\pyexbench} suite is further divided into three parts: {\pyextdbench},  {\pyexztbench} and {\pyexzzbench}, comprising 5,569, 8,414 and 11,438  instances, respectively. 

\smallskip
\noindent\kaluzabench~\cite{Berkeley-JavaScript}
%
is the most well-known  benchmark suite in  literature, 
containing 47,284 instances with regular constraints, concatenation, and the $\length$ function. The 47,284 benchmarks include 28,032 satisfiable and 9,058 unsatisfiable problems in SSA form.

\newcommand{\ostrichi}{\ostrich$^{(1)}$}
\newcommand{\ostrichii}{\ostrich$^{(2)}$}

\definecolor{Gray}{gray}{0.9}
%\newcolumntype{g}{>{\columncolor{Gray}}c}
\begin{table}[tbp]
\newcommand{\summary}[2]{\multirow{3}{*}{\begin{tabular}{c}#1\\Total: #2\end{tabular}}}
\begin{center}
\begin{tabular}{|c|c|*{6}{c|}}
\hline
Benchmark & Output &  \cvc & \zthree &  \zthreetrau & \ostrichi & \ostrichii & \ostrich+ \\
\hline
\hline
\summary{\transducerbench+}{94} & \cellcolor{Gray} sat &  \cellcolor{Gray}$-$ & \cellcolor{Gray}$-$ & \cellcolor{Gray}$-$ & \cellcolor{Gray}0 & \cellcolor{Gray}0 & \cellcolor{Gray}\bf{84}\\
\cline{2-8}
 & unsat &$-$  &$-$ &$-$ & 1 & 1 &\bf{4}\\
\cline{2-8}
 & \cellcolor{Gray}  inconcl.  &\cellcolor{Gray}$-$    &\cellcolor{Gray}$-$  &\cellcolor{Gray}$-$  &  \cellcolor{Gray}93 &  \cellcolor{Gray}93 &\cellcolor{Gray}6\\
%\cline{2-8} 
% & wrong &$-$  & $-$  &$-$ &0 \\
\hline
\hline
\summary{\slogbenchra}{120} & \cellcolor{Gray} sat &  \cellcolor{Gray}\bf{104}  & \cellcolor{Gray}$-$ & \cellcolor{Gray}$-$  & \cellcolor{Gray}0 & \cellcolor{Gray}0 &98 \cellcolor{Gray}\\
\cline{2-8}
 & unsat &11  &$-$  &$-$ & 7 & 5 &\bf{12}\\
\cline{2-8}
 &\cellcolor{Gray} inconcl. & \cellcolor{Gray}5  &\cellcolor{Gray}$-$ &\cellcolor{Gray}$-$ & \cellcolor{Gray}113 & \cellcolor{Gray}115 &\cellcolor{Gray}10\\
%\cline{2-8}
% & wrong &0 &$-$ &$-$  &0 \\
\hline
\hline
\summary{\slogbenchr}{3,391} & \cellcolor{Gray} sat &  \cellcolor{Gray}\bf{1,309} & \cellcolor{Gray}878 & \cellcolor{Gray}$-$ & \cellcolor{Gray}0 & \cellcolor{Gray}169 & \cellcolor{Gray}584 \\
\cline{2-8}
 & unsat & \bf{2,082} & 2,066  &$-$ &2,079 & 2,075 &\bf{2,082}\\
\cline{2-8}
 &\cellcolor{Gray}  inconcl. & \cellcolor{Gray}0  &  \cellcolor{Gray}447   &  \cellcolor{Gray}$-$ & \cellcolor{Gray}1,312 & \cellcolor{Gray}1,147 &\cellcolor{Gray}725\\
%\cline{2-8}
% & wrong &0 & 0  &$-$ &0\\
\hline
\hline
\summary{\pyextdbench}{5,569} & \cellcolor{Gray} sat & \cellcolor{Gray}4,224 & \cellcolor{Gray}4,068 &  \cellcolor{Gray} \bf{4,266} & \cellcolor{Gray}68 & \cellcolor{Gray}96 & \cellcolor{Gray}4,141\\
\cline{2-8}
 & unsat & 1,284 & 1,289 & \bf{1,295} & 95 & 93 &1,203\\
\cline{2-8}
 &\cellcolor{Gray} inconcl. &\cellcolor{Gray}61 &\cellcolor{Gray}212   &\cellcolor{Gray}8 & \cellcolor{Gray}5,406 & \cellcolor{Gray}5,380 &\cellcolor{Gray}225\\
%\cline{2-8}
% &wrong &0 & 0 &  0 &0 \\
\hline
\hline
\summary{\pyexztbench}{8,414} & \cellcolor{Gray} sat & \cellcolor{Gray}6,346 & \cellcolor{Gray}6,040 & \cellcolor{Gray}\bf{7,003} & \cellcolor{Gray}76 & \cellcolor{Gray}100 & \cellcolor{Gray}5,489\\
\cline{2-8}
 & unsat & 1,358  & 1,370  &\bf{1,394} & 61 & 53 &1,239\\
\cline{2-8}
 & \cellcolor{Gray}inconcl. &\cellcolor{Gray}710 &\cellcolor{Gray}1,004 &\cellcolor{Gray} 17 & \cellcolor{Gray}8,277 & \cellcolor{Gray}8,261 &\cellcolor{Gray}1,686\\
%\cline{2-8}
% & wrong & 0 &0 & 0 &0 \\
\hline
\hline
\summary{\pyexzzbench}{11,438} & \cellcolor{Gray} sat & \cellcolor{Gray} 10,078 & \cellcolor{Gray} 8,804 & \cellcolor{Gray} \bf{10,129} & \cellcolor{Gray}71 & \cellcolor{Gray}98 & \cellcolor{Gray}9,033\\
\cline{2-8}
 & unsat & 1,204 & 1,207  &   \bf{1,222} & 91 & 61 &868\\
\cline{2-8}
 &\cellcolor{Gray}  inconcl. &\cellcolor{Gray}156 & \cellcolor{Gray}1,427  &  \cellcolor{Gray} 87 & \cellcolor{Gray}11,276 & \cellcolor{Gray}11,279 &\cellcolor{Gray}1,537 \\
%\cline{2-8}
% & wrong &  0 & 0 & 0&0 \\
\hline
\hline
\summary{\kaluzabench}{47,284} & \cellcolor{Gray} sat &  \cellcolor{Gray} \bf{35,264} & \cellcolor{Gray} 33,438 & \cellcolor{Gray} 34,769 & \cellcolor{Gray}23,397 & \cellcolor{Gray}28,522 & \cellcolor{Gray}27,962\\
\cline{2-8}
 & unsat & \bf{12,014} &  11,799  &\bf{12,014}  & 10,445 & 10,445 &9,058\\
\cline{2-8}
 &\cellcolor{Gray} inconcl. &\cellcolor{Gray}6 & \cellcolor{Gray}2,047  &\cellcolor{Gray}501 & \cellcolor{Gray}13,442 & \cellcolor{Gray}8,317 &\cellcolor{Gray}10,264 \\
%\cline{2-8}
% & wrong &  0 & 0 &0 &0 \\
\hline 
\hline
\multirow{2}{*}{Total: 76,310} & \cellcolor{Gray} solved & \cellcolor{Gray}\bf{75,278}  & \cellcolor{Gray}70,959 & \cellcolor{Gray}72,092 & \cellcolor{Gray}36,391 & \cellcolor{Gray}41,718 & \cellcolor{Gray}61,857\\
\cline{2-8}
 &  unsolved &1,032  & 5,351  & 4,218 & 39,919 & 34,592 &14,453  \\
\hline
\end{tabular}
\end{center}
\caption{Experimental results on different benchmark suites.  '--' means that the tool is not applicable to the benchmark suite, and 'inconclusive' means that a tool gave up, timed out, or crashed.}
\label{tab-experiment}\vspace{-6mm}
\end{table}%

\vspace{-3mm}
\subsection{Experiments}\label{sec:exp-res}

We compare {\ostrich}+ to {\cvc}~\cite{cvc4}, {\zthree}~\cite{Z3-str},
and {\zthreetrau} \cite{Z3-trau}, as well as two configurations of
\ostrich~\cite{CHL+19} with standard NFAs. The configuration \ostrichi\ is
a direct implementation of the algorithm in \cite{CHL+19}, and does
not support integer functions. In \ostrichii, we integrated support
for the $\length$ function as in Norn~\cite{Abdulla14}, based on the
computation of length abstractions of regular languages, and handle
$\indexof$, $\substring$, and $\charat$ via an encoding to word equations.
%
The experiments are executed on a computer with an Intel Xeon Silver 4210 2.20GHz and 2.19GHz CPU (2-core) and 8GB main memory, running 64bit Ubuntu 18.04 LTS OS and Java 1.8. We use a timeout of 30~seconds (wall-clock time), and report the number of satisfiable and unsatisfiable problems solved by each of the systems. Table~\ref{tab-experiment} summarises the experimental results. We did not observe incorrect answers by any tool.
% (note that the ground-truth are known and have been verified \tl{check this}  

There are two additional state-of-the-art solvers  {\slent} and {\trauplus} which were not included in
the evaluation. We exclude {\slent}~\cite{WC+18} because it uses its own input format laut, which is different from the SMT-LIB~2 format used for our
benchmarks; also, {\transducerbench+} is beyond the scope of {\slent}.
%
{\trauplus}~\cite{AbdullaA+19}  integrates {\trau} with {\sloth} to deal with both finite transducers and integer constraints. We were unfortunately unable
to obtain a working version of {\trauplus}, possibly because {\trau} requires two separate versions of Z3 to run. In addition, the algorithm in~\cite{AbdullaA+19} focuses on length-preserving transducers, which means that {\transducerbench}+ is beyond the scope of \trauplus.
 
{\ostrich}+ and \ostrich\ are the only tools applicable to the
problems in {\transducerbench}+. With a timeout of 30s, \ostrich+ can
solve 88 of the benchmarks, but this number rises to 94 when using a
longer timeout of 600s. Given the complexity of those benchmarks, this
is an encouraging result. \ostrich\ can only solve one of the
benchmarks, because the encoding of $\charat$ in the benchmarks using
equations almost always leads to problems that are not in SSA form.

On {\slogbenchra}, {\ostrich}+ and {\cvc} are very close: {\ostrich}+ solves 98 satisfiable instances, slightly less than the 104 instances solved by {\cvc}, while {\ostrich}+ solves one more unsatisfiable instance than {\cvc} (12 versus 11). The suite is beyond the scope of {\zthree} and {\zthreetrau}, which do not support $\replaceall$.

On {\slogbenchr}, {\ostrich}+, {\cvc}, and {\zthree} solve a similar
number of unsatisfiable problems, while {\cvc} solves the largest
number of satisfiable instances (1,309). The  suite %{\slogbenchr} benchmark
is beyond the scope of {\zthreetrau} which does not support
$\replace$.

On the three \pyexbench\ suites, {\zthreetrau} consistently solves the
largest number of instances by some margin. \ostrich+ solves a similar
number of instances as \zthree. Interpreting the results, however, it
has to be taken into account that \pyexbench\  includes 1,334  instances
that are \emph{not} in SSA form, which are beyond the scope of
\ostrich+.

%\iffalse
%For {\pyextdbench}, each of the four solvers is able to solve more than 95\% of the benchmark instances and their performances are close, with {\zthreetrau} the best, followed by {\cvc}, then {\zthree}, and finally {\ostrich}+.  
%
%For {\pyexztbench}, {\zthreetrau} is the best, solving almost all instances. %, except 17 of them. 
%{\cvc} and {\zthree} are ranked in the second and third place. The performance of {\ostrich}+ on this benchmark suite is not very impressive, only solving around 80\% instances.
%
%For {\pyexzzbench}, %\zhilin{to be done}
%{\zthreetrau} again is the best, which is followed closely by {\cvc}. %solving almost all instances. %, except 17 of them. 
%%{\cvc} and {\zthree} are ranked in the second and third place. 
%The performance of {\ostrich}+ and {\zthree} are level, but are 10\% worse than  {\zthreetrau} and {\cvc}. %on this benchmark suite is not very impressive, only solving around 80\% instances.
%\fi

The {\kaluzabench} problems can be solved most effectively by {\cvc}. \ostrich+ can solve almost all of the around 80\% of the benchmarks
that are in SSA form, however.
%
%\ostrich+ can solve almost all of the 28,032 satisfiable
%problems in SSA form, and all 9,058 unsatisfiable problems in SSA
%form. This is consistent with the results in  \cite{CHL+19} for
%{\ostrich}.

\ostrich+ consistently outperforms \ostrichi\ and \ostrichii\ in the
evaluation, except for the \kaluzabench\ benchmarks. For
\ostrichi, this is expected because most benchmarks considered
here contain integer functions. For \ostrichii, it turns out that the
encoding of $\indexof$, $\substring$, and $\charat$ as word equations
usually leads to problems that are not in SSA form, and therefore are
beyond the scope of \ostrich.

%\iffalse
%{\zthreetrau} solves slightly less instances, but solves the same number of unsatisfiable instances as {\cvc}. {\zthree} is the third on the {\kaluzabench} suite. 
%%The performance of 
%{\ostrich}+ %is not that satisfactory on this suite and it  
%solves  around 80\%  instances. The main reason is that about 20\% {\kaluzabench} instances cannot be written as programs in the SSA form, thus cannot be handled by%out of the scope of 
%{\ostrich} or {\ostrich}+. This  is consistent with the observation for {\ostrich} \cite{CHL+19}.
%\fi

In summary, we  observe that \ostrich+ is competitive with other solvers, while is able to handle benchmarks that are beyond
the scope of the other tools due to the combination of string functions (in particular transducers) and integer
constraints. Interestingly, the experiments show that \ostrich+, at
least in its current state, is better at solving unsatisfiable problems than satisfiable problems; this might be an artefact of the
use of nuXmv for analysing products of CEFAs. We expect that further
optimisation of our algorithm will lead to additional performance improvements. 
For instance, a natural optimisation that is to be
included in our implementation is to use standard finite automata, %like in \ostrich, 
as opposed to CEFAs, for simpler problems such as the
\kaluzabench\ benchmarks. Such a combination of automata
representations is mostly an engineering effort.

%\iffalse
%%Last but not least, we would like to summarise and highlight some facts and observations about {\ostrich}+  according to the experimental results in Table~\ref{tab-experiment}.
%In summary, 
%%\begin{itemize}
%%\item 
%{\ostrich}+ is the only string solver that is capable of solving string constraints involving both finite transducers and integer constraints. In particular, it is the only string solver that is able to verify idempotence, duality, commutativity, and equivalence of HTML sanitisation operations.
%%
%{\ostrich}+ is generally better at solving unsatisfiable benchmark instances. It solves the most instances on both {\slogbenchra} and {\slogbenchr} benchmark suites. Moreover, the number of the unsatisfiable instances of {\pyexbench} resp. {\kaluzabench} solved by {\ostrich}+ is close to that of the best solver. %, compared to the number of solved satisfiable instances.   \zhilin{to be double checked later}
%
%%\end{itemize}
%Admittedly, {\ostrich}+ has not exceeded other mature solvers when dealing with relatively simple string operations. However, considering that it implemented a ()complete) decision procedure (while others rely on heuristics) and its strength in dealing with complex string operations and integer constraints, we may conclude that {\ostrich}+ is competitive, and has much potential to improve when heuristics are introduced to deal with  satisfiable  instances more efficiently. 
%\fi

 
