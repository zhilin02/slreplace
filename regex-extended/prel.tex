\section{Preliminaries}

Throughout the paper, $\Int^+$ denotes the set of positive integers, and  $\nat$ denotes the set of natural numbers. Furthermore, for $n\in \Int^+$, let $[n]:=\{1, \ldots, n\}$. 

\begin{definition}[Finite-state automata] \label{def:nfa}
	A \emph{(nondeterministic) finite-state automaton}
	(\FA{}) over a finite alphabet $\ialphabet$ is a tuple $\Aut =
	(\ialphabet, \controls, q_0, \finals, \transrel)$ where 
	$\controls$ is a finite set of 
	states, $q_0\in \controls$ is
	the initial state, $\finals\subseteq \controls$ is a set of final states, and 
	$\transrel\subseteq \controls \times 
	\ialphabet \times  \controls$ is the
	transition relation. 
\end{definition}

For an input string $w=a_1 \dots a_n$, a \emph{run} of $\Aut$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a sequence of states $q_0, \ldots, q_n$ such that $(q_{j-1}, a_{j}, q_{j}) \in
\transrel$  for every $j \in [n]$.
The run is said to be \defn{accepting} if $q_n \in \finals$.
A string $w$ is \defn{accepted} by $\Aut$ if there is an accepting run of
$\Aut$ on $w$. In particular, the empty string $\varepsilon$ is accepted by $\Aut$ if $q_0 \in F$. The set of strings accepted by $\Aut$, i.e., the language \defn{recognised} by $\Aut$, is denoted by $\Lang(\Aut)$.
%Since we deal with computational complexity in the sequel, we define
The \defn{size} $|\Aut|$ of $\Aut$ is defined to be the cardinality of the set $Q$ of states, which will be 
used when the computational complexity is concerned.

For convenience, for $a \in \Sigma$, we use $\delta^{(a)}$ to denote the  relation $\{(q, q') \mid (q, a, q') \in \delta\}$.

For a finite set $Q$, let $\overline{Q} = \bigcup_{n\in \Nat}\{ (q_1, \ldots, q_n) \mid \forall i \in [n], q_i \in Q \wedge \forall i,j \in[n], i \neq j \rightarrow q_i \neq q_j \}$. Intuitively, $\overline{Q}$ is the set of sequences of non-repetitive elements from $Q$. Note that the length of each sequence from $\overline{Q}$ is bounded by  $| Q |$. For a sequence $P = (q_0 \ldots q_n) \in \overline{Q}$ and  $q \in Q$, we write $q \in P$ if  $q = q_i$ for some $i \in [n]$. 

\tl{move this to the section of PSST?}
\begin{definition}[Prioritized Finite-state automata]
  A \emph{prioritized finite-state automaton} (pNFA) over a finite alphabet $\Sigma$ is a tuple $\pnfa=(Q, \Sigma, \delta, q_0, F)$ where $\delta \in Q
  \times \Sigma \rightarrow \overline{Q}$. The definition of $Q, q_0$ and $F$ is the same as ordinary NFA.
\end{definition}

A run of $\pnfa$ is the sequence $q_0 \sigma_1 q_1 \ldots \sigma_m q_m$, where $q_m \in F$ and for any $i \in [m], q_i \in \delta (q_{i - 1}, \sigma_i)$. For any two runs $p = q_0 \sigma_1 q_1 \ldots \sigma_m q_m$ and $p' =  q_0 \sigma_1 q_1' \ldots \sigma_m q_m'$ on $w = \sigma_1 \ldots \sigma_m$, we say that $p$ is of a higher priority over  $p'$ if $p \neq p'$, and for the smallest index $j$ with $q_j \neq q_j'$, $\delta (q_{j - 1}, \sigma_j) = \ldots q_j \ldots q_j' \ldots$.
  
  The accepting run of $\pnfa$ on $w$ is the one with the highest priority. The language of pNFA $\pnfa$ is the set of
  strings which have an accepting run.
  
  
  
  \subsection{Extended regular expressions}
  
  A regular expression (with capturing group and back reference) is defined as follows.
  
  \begin{definition}[Regular expressions with capturing group and back reference $\regexp$]
  	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e)  , \]
  	where $a \in \Sigma, n \in \Int^+$. 
  	%	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. 
  	%We use the abbreviation 
  	$e^+$ abbreviates $e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we write $\Gamma \equiv a_1 + \cdots + a_k$ and $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 
  \end{definition}
  \zhilin{some sanity conditions should be put to make the semantics of $\$ n$ well-defined.}
  
  Note that standard regular expressions are those without $\$ n$ or $(e)$.
  %
  
  Moreover, we use $\regexp[\sf CG]$ to denote the fragment of $\regexp$  excluding $\$ n$, and $\refexp$ to denote expressions generated by $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.
  %\tl{define the semantics here?}
  
  %\label{semantics:regex}
  
  
  
  %\subsection{Semantics of \regexp[\sf CG]}
  %In this section, we give one of the many semantics of \regexp[\sf CG], which we will utilize for $\replaceall$.
  
  \begin{definition}[Subexpression]
  	For any two $\regexp[\sf CG]$ $e$ and $r$, we say $r$ is a subexpression of $e$,
  	if either $r=e$ or
  	\begin{itemize}
  		\item If $e = e_1 e_2$ or $e_1 + e_2$ then $r$ is a subexpression of $e_1$
  		or $e_2$
  		
  		\item If $e = e_1^{\ast}$ or $(e_1)$ then $r$ is a subexpression of $e_1$
  	\end{itemize}
  	We use $S (e)$ to denote the set of all subexpressions of $e$.
  \end{definition}
  
  
  \begin{definition}[Match Tree]
  	A \tmtextbf{match tree} of $\regexp[\sf CG]$ $e$ is a finite directed and ordered
  	tree T, whose nodes are elements of $\Sigma^{\ast} \times S (e)$. A tree
  	is valid if the root is $(w, e)$ for some string w, and for any node $u =
  	(w, \alpha)$ in T, we have:
  	\begin{itemize}
  		\item If $\alpha = \alpha_1 \alpha_2$ then u has two children $(w_1,
  		\alpha_1)$ and $(w_2, \alpha_2)$ where $w = w_1 w_2$.
  		
  		\item If $\alpha = \alpha_1 + \alpha_2$ then u has a single child $(w,
  		\alpha_i)$ where $i \in \{ 1, 2 \}$.
  		
  		\item If $\alpha = \alpha_1^{\ast}$ then when $w = \varepsilon$, u is a
  		leaf otherwise there is $k \geqslant 1$ such that u has k children $(w_1,
  		\alpha_1), \ldots, (w_k, \alpha_1)$ where $w = w_1 \ldots w_k$ and for all
  		$i \in [k]$, $w_i \neq \varepsilon$, even if $\varepsilon \in L
  		(\alpha_1)$.
  		
  		\item If $\alpha = (\alpha_1)$ then u has a single child $(w, \alpha_1)$.
  		
  		\item If $\alpha = a$ (resp. $\alpha = \varepsilon$) then u is a leaf and
  		$w = a$ (resp. $w = \varepsilon$).
  	\end{itemize}
  	
  	Whenever unambiguous, we use a node u to represent the whole subtree
  	where u is the root. The notation $C(T)$ refers to all direct children of the root node of T
  	(and thus all direct subtrees).
  	
  	We also use $M (e)$ to denote all the valid match trees of e.
  \end{definition}
  
  \begin{definition}[Semantics of RegExp{[\sf CG]}]
  	\
  	
  	For any $\regexp[\sf CG]$ e, we recursively define a total order on $M (e)$, written $m
  	>_e n$ where $m, n \in M (e)$, as follows:
  	\begin{itemize}
  		\item $e = \varepsilon$ or $e = a$. There is only one match tree, thus the
  		order $>_e$ is empty.
  		
  		\item $e = (e_1)$. Suppose $C (m) = (w_1, e_1)$ and $C (n) = (w_2, e_1)$,
  		then $m >_e n$ iff $(w_1, e_1) >_{e_1} (w_2, e_1)$.
  		
  		\item $e = e_1 + e_2$.
  		\begin{itemize}
  			\item If $C (m) = (w, e_1)$ and $C (n) = (w', e_2)$, then $m >_e n$.
  			
  			\item If $C (m) = (w, e_i)$ and $C (n) = (w', e_i)$, where $i \in \{ 1,
  			2 \}$, then $m >_e n$ iff $(w, e_i) >_{e_i} (w', e_i)$.
  		\end{itemize}
  		\item $e = e_1 e_2$. Suppose $C (m) = (w_1, e_1) (w_2, e_2)$ and $C (n) =
  		(w_1', e_1) (w_2', e_2)$, then $m >_e n$ when either $(w_1, e_1) >_{e_1}
  		(w_1', e_1)$, or $w_1 = w_1'$ and $(w_2, e_2) >_{e_2} (w_2', e_2)$.
  		
  		\item $e = e_1^{\ast}$. If n is a leaf but m is not, then $m >_e n$.
  		Otherwise, suppose $C (m) = (w_1, e_1), \ldots, (w_k, e_1)$ and $C (n) =
  		(w_1', e_1), \ldots, (w_l', e_1)$, we have $m >_e n$ either when $C (n)$
  		is a proper prefix of $C (m)$, or for the first index j such that $w_j
  		\neq w_j'$, $(w_j, e_1) >_{e_1} (w_j', e_1)$.
  	\end{itemize}
  	
  	Let $e \in \regexp[\sf CG]$, and string $w \in L (e)$, then the accepting match of w
  	on e, denoted by $m_e (w)$, is the supremum of the set $\{ m \in M (e) \mid m = (w, e) \}$.
  	
  	For any subexpression $e'$ of e, suppose $(w_1, e') \ldots (w_m, e')$ are
  	all the nodes labeled by $(w', e')$, where $w' \neq \varepsilon$, in the
  	pre-order traversal of $m_e (w)$. Then the match result captured by $e'$, denoted
  	by $m_{e', e} (w)$, is the sequence of substring $w_1 \ldots w_m$.
  \end{definition}
  
  \zhilei{Give an example here}