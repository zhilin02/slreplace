\section{Preliminaries}

Throughout the paper, $\Int^+$ denotes the set of positive integers, and  $\nat$ denotes the set of natural numbers. Furthermore, for $n\in \Int^+$, let $[n]:=\{1, \ldots, n\}$. 

\begin{definition}[Finite-state automata] \label{def:nfa}
	A \emph{(nondeterministic) finite-state automaton}
	(\FA{}) over a finite alphabet $\ialphabet$ is a tuple $\Aut =
	(\ialphabet, \controls, q_0, \finals, \transrel)$ where 
	$\controls$ is a finite set of 
	states, $q_0\in \controls$ is
	the initial state, $\finals\subseteq \controls$ is a set of final states, and 
	$\transrel\subseteq \controls \times 
	\ialphabet \times  \controls$ is the
	transition relation. 
\end{definition}

For an input string $w=a_1 \dots a_n$, a \emph{run} of $\Aut$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a sequence of states $q_0, \ldots, q_n$ such that $(q_{j-1}, a_{j}, q_{j}) \in
\transrel$  for every $j \in [n]$.
The run is said to be \defn{accepting} if $q_n \in \finals$.
A string $w$ is \defn{accepted} by $\Aut$ if there is an accepting run of
$\Aut$ on $w$. In particular, the empty string $\varepsilon$ is accepted by $\Aut$ if $q_0 \in F$. The set of strings accepted by $\Aut$, i.e., the language \defn{recognised} by $\Aut$, is denoted by $\Lang(\Aut)$.
%Since we deal with computational complexity in the sequel, we define
The \defn{size} $|\Aut|$ of $\Aut$ is defined to be the cardinality of the set $Q$ of states, which will be 
used when the computational complexity is concerned.

For convenience, for $a \in \Sigma$, we use $\delta^{(a)}$ to denote the  relation $\{(q, q') \mid (q, a, q') \in \delta\}$.


  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Extended regular expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
An (extend) regular expression (with capturing group and back reference) is defined as follows.
  
\begin{definition}[Regular expressions with capturing group and back reference, $\regexp$]
  	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e)  , \]
  	where $a \in \Sigma, n \in \Int^+$. 
  	%	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. 
  	%We use the abbreviation 
\end{definition}
  	
We use $e^+$ to abbreviate $e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we write $\Gamma$ for  $a_1 + \cdots + a_k$ and thus  $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 

We assume that the parentheses in a regular expression are well matched. 
%
%Besides the common rules governing regular expressions, a regex obeys
%the following syntactic rule: 
Moreover, every back reference $\$ n$ is found to the right of the $n$-th pair of parentheses, where parentheses
are indexed according to the occurrence sequence of their left parenthesis.
\zhilin{some sanity conditions should be put to make the semantics of $\$ n$ well-defined.}
  
Note that standard regular expressions are those without $\$ n$ or $(e)$. Moreover, we use $\regexp[\sf CG]$ to denote the fragment of $\regexp$  excluding $\$ n$, and $\refexp$ to denote expressions generated by $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.
  %\tl{define the semantics here?}
  
  %\label{semantics:regex}
  
  
  
  %\subsection{Semantics of \regexp[\sf CG]}
  %In this section, we give one of the many semantics of \regexp[\sf CG], which we will utilize for $\replaceall$.
  
  \begin{definition}[Subexpression]
  	For any two $\regexp[\sf CG]$ $e$ and $r$, we say $r$ is a subexpression of $e$,
  	if either $r=e$ or
  	\begin{itemize}
  		\item If $e = e_1 e_2$ or $e_1 + e_2$ then $r$ is a subexpression of $e_1$
  		or $e_2$
  		
  		\item If $e = e_1^{\ast}$ or $(e_1)$ then $r$ is a subexpression of $e_1$
  	\end{itemize}
  	We use $S (e)$ to denote the set of all subexpressions of $e$.
  \end{definition}
  
  
  \begin{definition}[Match Tree]
  	A \tmtextbf{match tree} of $\regexp[\sf CG]$ $e$ is a finite directed and ordered
  	tree T, whose nodes are elements of $\Sigma^{\ast} \times S (e)$. A tree
  	is valid if the root is $(w, e)$ for some string w, and for any node $u =
  	(w, \alpha)$ in T, we have:
  	\begin{itemize}
  		\item If $\alpha = \alpha_1 \alpha_2$ then u has two children $(w_1,
  		\alpha_1)$ and $(w_2, \alpha_2)$ where $w = w_1 w_2$.
  		
  		\item If $\alpha = \alpha_1 + \alpha_2$ then u has a single child $(w,
  		\alpha_i)$ where $i \in \{ 1, 2 \}$.
  		
  		\item If $\alpha = \alpha_1^{\ast}$ then when $w = \varepsilon$, u is a
  		leaf otherwise there is $k \geqslant 1$ such that u has k children $(w_1,
  		\alpha_1), \ldots, (w_k, \alpha_1)$ where $w = w_1 \ldots w_k$ and for all
  		$i \in [k]$, $w_i \neq \varepsilon$, even if $\varepsilon \in L
  		(\alpha_1)$.
  		
  		\item If $\alpha = (\alpha_1)$ then u has a single child $(w, \alpha_1)$.
  		
  		\item If $\alpha = a$ (resp. $\alpha = \varepsilon$) then u is a leaf and
  		$w = a$ (resp. $w = \varepsilon$).
  	\end{itemize}
  	
  	Whenever unambiguous, we use a node u to represent the whole subtree
  	where u is the root. The notation $C(T)$ refers to all direct children of the root node of T
  	(and thus all direct subtrees).
  	
  	We also use $M (e)$ to denote all the valid match trees of e.
  \end{definition}
  
  \begin{definition}[Semantics of RegExp{[\sf CG]}]
  	\
  	
  	For any $\regexp[\sf CG]$ e, we recursively define a total order on $M (e)$, written $m
  	>_e n$ where $m, n \in M (e)$, as follows:
  	\begin{itemize}
  		\item $e = \varepsilon$ or $e = a$. There is only one match tree, thus the
  		order $>_e$ is empty.
  		
  		\item $e = (e_1)$. Suppose $C (m) = (w_1, e_1)$ and $C (n) = (w_2, e_1)$,
  		then $m >_e n$ iff $(w_1, e_1) >_{e_1} (w_2, e_1)$.
  		
  		\item $e = e_1 + e_2$.
  		\begin{itemize}
  			\item If $C (m) = (w, e_1)$ and $C (n) = (w', e_2)$, then $m >_e n$.
  			
  			\item If $C (m) = (w, e_i)$ and $C (n) = (w', e_i)$, where $i \in \{ 1,
  			2 \}$, then $m >_e n$ iff $(w, e_i) >_{e_i} (w', e_i)$.
  		\end{itemize}
  		\item $e = e_1 e_2$. Suppose $C (m) = (w_1, e_1) (w_2, e_2)$ and $C (n) =
  		(w_1', e_1) (w_2', e_2)$, then $m >_e n$ when either $(w_1, e_1) >_{e_1}
  		(w_1', e_1)$, or $w_1 = w_1'$ and $(w_2, e_2) >_{e_2} (w_2', e_2)$.
  		
  		\item $e = e_1^{\ast}$. If n is a leaf but m is not, then $m >_e n$.
  		Otherwise, suppose $C (m) = (w_1, e_1), \ldots, (w_k, e_1)$ and $C (n) =
  		(w_1', e_1), \ldots, (w_l', e_1)$, we have $m >_e n$ either when $C (n)$
  		is a proper prefix of $C (m)$, or for the first index j such that $w_j
  		\neq w_j'$, $(w_j, e_1) >_{e_1} (w_j', e_1)$.
  	\end{itemize}
  	
  	Let $e \in \regexp[\sf CG]$, and string $w \in L (e)$, then the accepting match of w
  	on e, denoted by $m_e (w)$, is the supremum of the set $\{ m \in M (e) \mid m = (w, e) \}$.
  	
  	For any subexpression $e'$ of e, suppose $(w_1, e') \ldots (w_m, e')$ are
  	all the nodes labeled by $(w', e')$, where $w' \neq \varepsilon$, in the
  	pre-order traversal of $m_e (w)$. Then the match result captured by $e'$, denoted
  	by $m_{e', e} (w)$, is the sequence of substring $w_1 \ldots w_m$.
  \end{definition}
  
  \zhilei{Give an example here}