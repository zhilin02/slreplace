%!TEX root = main.tex

\section{Preliminaries}

Throughout the paper, $\Int^+$ denotes the set of positive integers, and  $\nat$ denotes the set of natural numbers. Furthermore, for $n\in \Int^+$, let $[n]:=\{1, \ldots, n\}$. 

We use $\Sigma$ to denote a finite set of letters, called \emph{alphabet}. A \emph{string} over $\Sigma$ is a finite sequence of letters from $\Sigma$. We use $\Sigma^*$ to denote the set of strings over $\Sigma$. 

\begin{definition}[Finite-state automata] \label{def:nfa}
	A \emph{(nondeterministic) finite-state automaton}
	(\FA{}) over a finite alphabet $\ialphabet$ is a tuple $\Aut =
	(\ialphabet, \controls, q_0, \finals, \transrel)$ where 
	$\controls$ is a finite set of 
	states, $q_0\in \controls$ is
	the initial state, $\finals\subseteq \controls$ is a set of final states, and 
	$\transrel\subseteq \controls \times 
	\ialphabet \times  \controls$ is the
	transition relation. 
\end{definition}

For an input string $w=a_1 \dots a_n$, a \emph{run} of $\Aut$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a sequence of states $q_0, \ldots, q_n$ such that $(q_{j-1}, a_{j}, q_{j}) \in
\transrel$  for every $j \in [n]$.
The run is said to be \defn{accepting} if $q_n \in \finals$.
A string $w$ is \defn{accepted} by $\Aut$ if there is an accepting run of
$\Aut$ on $w$. In particular, the empty string $\varepsilon$ is accepted by $\Aut$ if $q_0 \in F$. The set of strings accepted by $\Aut$, i.e., the language \defn{recognised} by $\Aut$, is denoted by $\Lang(\Aut)$.
%Since we deal with computational complexity in the sequel, we define
The \defn{size} $|\Aut|$ of $\Aut$ is defined to be the cardinality of the set $Q$ of states, which will be 
used when the computational complexity is concerned.

For convenience, for $a \in \Sigma$, we use $\delta^{(a)}$ to denote the  relation $\{(q, q') \mid (q, a, q') \in \delta\}$.


  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Extended regular expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
An (extend) regular expression (with capturing group and back reference) is defined as follows.
  
\begin{definition}[Regular expressions with capturing group and back reference, $\regexp$]
  	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e)  , \]
  	where $a \in \Sigma, n \in \Int^+$. 
  	%	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. 
  	%We use the abbreviation 
\end{definition}
We abbreviate $e \concat e^*$ as $e^+$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we write $\Gamma$ for  $a_1 + \cdots + a_k$ and thus  $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 

Note that parentheses in $\regexp$ are used for both precedence and capturing. 
%We assume that the parentheses in every regular expression are well matched. 
%
%Besides the common rules governing regular expressions, a regex obeys
%the following syntactic rule: 
Every back reference $\$ n$ is found to the right of the $n$-th pair of parentheses, where parentheses
are indexed according to the occurrence sequence of their left parenthesis. For instance, $((a+b)^*) c \$1$ is in $\regexp$, where $\$1$ refers to the matching of the subexpression $(a+b)^*$. Intuitively, it denotes the set of strings of the form $u c u$, where $u$ is a string with each letter being $a$ or $b$.
  
%Note that standard regular expressions are those without $\$ n$. 
%Moreover, 
We use $\regexp[\sf CG]$ to denote the fragment of $\regexp$  excluding $\$ n$, and $\refexp$ to denote the set of expressions generated by $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.
  %\tl{define the semantics here?}
  
  %\label{semantics:regex}
  
  
  
  %\subsection{Semantics of \regexp[\sf CG]}
  %In this section, we give one of the many semantics of \regexp[\sf CG], which we will utilize for $\replaceall$.
  
  \begin{definition}[Subexpression]
  	For any two $\regexp[\sf CG]$ $e$ and $r$, we say $r$ is a subexpression of $e$,
  	if either $r=e$ or
  	\begin{itemize}
  		\item If $e = e_1 e_2$ or $e_1 + e_2$ then $r$ is a subexpression of $e_1$
  		or $e_2$
  		
  		\item If $e = e_1^{\ast}$ or $(e_1)$ then $r$ is a subexpression of $e_1$
  	\end{itemize}
  	We use $S (e)$ to denote the set of all subexpressions of $e$.
  \end{definition}

We are going to define the semantics of $\regexp$, which uses a concept of matches of $e \in \regexp$ to strings $w$ defined in the sequel.
  
  \begin{definition}[Match of $\regexp$ to strings]
  	A \tmtextbf{match} of $\regexp$ $e$ to a string $w$ is defined by a finite directed and ordered
  	tree $T$, whose nodes are elements of $\Sigma^{\ast} \times S (e)$ satisfying the following constraints: Its root is $(w, e)$, and for any node $\alpha =
  	(w', e')$ in $T$, we have:
  	\begin{itemize}
  		\item If $e' = e'_1 \concat e'_2$, then $\alpha$ has two children $\alpha_1 = (w'_1,
  		e'_1)$ and $\alpha_2=(w'_2, e'_2)$ where $w' = w'_1 w'_2$.
  		
  		\item If $e' = e'_1 + e'_2$, then $\alpha$ has a single child $\alpha_1 = (w',
  		e'_i)$ where $i \in \{ 1, 2 \}$.
  		
  		\item If $e' = {e'_1}^{\ast}$, then when $w' = \varepsilon$, $\alpha$ is a
  		leaf, otherwise there is $k \geqslant 1$ such that $\alpha$ has $k$ children $\alpha_1 = (w'_1,
  		e'_1), \ldots, \alpha_k = (w'_k, e'_1)$ where $w' = w'_1 \ldots w'_k$ and for all
  		$i \in [k]$, $w'_i \neq \varepsilon$, even if $\varepsilon \in L
  		(e'_1)$.
  		
  		\item If $e' = (e'_1)$, then $\alpha$ has a single child $\alpha_1 = (w', e'_1)$.
  		
  		\item If $e' = a$ (resp. $e' = \varepsilon$), then $\alpha$ is a leaf and
  		$w' = a$ (resp. $w' = \varepsilon$).
		
		\item If $e' = \$n$, then $\alpha$ is a leaf of $T$, moreover, let $e'' \in S(e)$ be enclosed by the $n$-th pair of parentheses in $e$ and $\beta = (w_1, e_1)$ be the last node preceding $\alpha$ in $T$ such that $e_1 = e''$, according to the left-to-right ordering of the nodes, then $w' = w_1$.
  	\end{itemize}
  	
%  	Whenever unambiguous, we use a node u to represent the whole subtree
 We use $T_\alpha$ to represent the subtree of $T$ rooted at $\alpha$. 
 % 	where u is the root. 
	The notation $C(T)$ refers to all direct children of the root node of T
  	(and thus all direct subtrees).
  	We also use $M (e)$ to denote all match trees of $e$.
  \end{definition}
  
  \begin{definition}[Semantics of RegExp{[\sf CG]}]
  	\
  	
  	For any $\regexp[\sf CG]$ e, we recursively define a total order on $M (e)$, written $m
  	>_e n$ where $m, n \in M (e)$, as follows:
  	\begin{itemize}
  		\item $e = \varepsilon$ or $e = a$. There is only one match tree, thus the
  		order $>_e$ is empty.
  		
  		\item $e = (e_1)$. Suppose $C (m) = (w_1, e_1)$ and $C (n) = (w_2, e_1)$,
  		then $m >_e n$ iff $(w_1, e_1) >_{e_1} (w_2, e_1)$.
  		
  		\item $e = e_1 + e_2$.
  		\begin{itemize}
  			\item If $C (m) = (w, e_1)$ and $C (n) = (w', e_2)$, then $m >_e n$.
  			
  			\item If $C (m) = (w, e_i)$ and $C (n) = (w', e_i)$, where $i \in \{ 1,
  			2 \}$, then $m >_e n$ iff $(w, e_i) >_{e_i} (w', e_i)$.
  		\end{itemize}
  		\item $e = e_1 e_2$. Suppose $C (m) = (w_1, e_1) (w_2, e_2)$ and $C (n) =
  		(w_1', e_1) (w_2', e_2)$, then $m >_e n$ when either $(w_1, e_1) >_{e_1}
  		(w_1', e_1)$, or $w_1 = w_1'$ and $(w_2, e_2) >_{e_2} (w_2', e_2)$.
  		
  		\item $e = e_1^{\ast}$. If n is a leaf but m is not, then $m >_e n$.
  		Otherwise, suppose $C (m) = (w_1, e_1), \ldots, (w_k, e_1)$ and $C (n) =
  		(w_1', e_1), \ldots, (w_l', e_1)$, we have $m >_e n$ either when $C (n)$
  		is a proper prefix of $C (m)$, or for the first index j such that $w_j
  		\neq w_j'$, $(w_j, e_1) >_{e_1} (w_j', e_1)$.
  	\end{itemize}
  	
  	Let $e \in \regexp[\sf CG]$, and string $w \in L (e)$, then the accepting match of w
  	on e, denoted by $m_e (w)$, is the supremum of the set $\{ m \in M (e) \mid m = (w, e) \}$.
  	
  	For any subexpression $e'$ of e, suppose $(w_1, e') \ldots (w_m, e')$ are
  	all the nodes labeled by $(w', e')$, where $w' \neq \varepsilon$, in the
  	pre-order traversal of $m_e (w)$. Then the match result captured by $e'$, denoted
  	by $m_{e', e} (w)$, is the sequence of substring $w_1 \ldots w_m$.
  \end{definition}
  
  \zhilei{Give an example here}