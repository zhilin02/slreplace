(set-option :parse-transducers true)
(define-funs-rec ((elimWhiteRightRel ((x String) (y String)) Bool) (elimWhiteRightHelp1 ((x String) (y String)) Bool) (elimWhiteRightHelp2 ((x String) (y String)) Bool)) ((or (and (= x "") (= y "")) (and (elimWhiteRightHelp1 x y)) (and (elimWhiteRightHelp2 x y))) (or (and (not (= x "")) (not (= y "")) (= (str.head x) (str.head y)) (elimWhiteRightHelp1 (str.tail x) (str.tail y))) (and (not (= x "")) (not (= y "")) (not (= (str.head_code x) (str.to_code " "))) (= (str.head x) (str.head y)) (elimWhiteRightHelp2 (str.tail x) (str.tail y)))) (or (and (= x "") (= y "")) (and (not (= x "")) (= (str.head_code x) (str.to_code " ")) (elimWhiteRightHelp2 (str.tail x) y)))))
(define-funs-rec ((elimWhiteLeftRel ((x String) (y String)) Bool) (elimWhiteLeftHelp ((x String) (y String)) Bool)) ((or (and (= x "") (= y "")) (and (not (= x "")) (= (str.head_code x) (str.to_code " ")) (elimWhiteLeftRel (str.tail x) y)) (and (not (= x "")) (not (= y "")) (not (= (str.head_code x) (str.to_code " "))) (= (str.head x) (str.head y)) (elimWhiteLeftHelp (str.tail x) (str.tail y)))) (or (and (= x "") (= y "")) (and (not (= x "")) (not (= y "")) (= (str.head x) (str.head y)) (elimWhiteLeftHelp (str.tail x) (str.tail y))))))
(define-fun elimWhiteRight ((x String)) String (_eps ((y String)) (elimWhiteRightRel x y)))
(define-fun elimWhiteLeft ((x String)) String (_eps ((y String)) (elimWhiteLeftRel x y)))
(declare-fun Constructed_Argument_t () String)
(declare-fun Constructed_Argument_2_t () String)
(declare-fun Constructed_Argument_3_t () String)
(declare-fun CreateAsClass () Bool)
(declare-fun Constructed_Argument () String)
(declare-fun |IsMatch_/BS{.*BS}/_0| () Bool)
(declare-fun |IsMatch_/BS/+/_1| () Bool)
(assert (= Constructed_Argument_t "string"))
(assert (not (= Constructed_Argument_2_t "string")))
(assert (not (= Constructed_Argument_2_t "number")))
(assert (not (= Constructed_Argument_2_t "boolean")))
(assert (not (= Constructed_Argument_2_t "object")))
(assert (not (= Constructed_Argument_2_t "array_number")))
(assert (not (= Constructed_Argument_2_t "array_string")))
(assert (not (= Constructed_Argument_2_t "array_bool")))
(assert (not (= Constructed_Argument_2_t "null")))
(assert (not (= Constructed_Argument_3_t "string")))
(assert (not (= Constructed_Argument_3_t "number")))
(assert (not (= Constructed_Argument_3_t "boolean")))
(assert (not (= Constructed_Argument_3_t "object")))
(assert (not (= Constructed_Argument_3_t "array_number")))
(assert (not (= Constructed_Argument_3_t "array_string")))
(assert (not (= Constructed_Argument_3_t "array_bool")))
(assert (not (= Constructed_Argument_3_t "null")))
(assert (not CreateAsClass))
(assert (not (= (elimWhiteRight (elimWhiteLeft Constructed_Argument)) "")))
(assert (= (str.in.re (elimWhiteRight (elimWhiteLeft Constructed_Argument)) (re.++ (re.* (re.range "\x00" "\xff")) (str.to.re "{") (re.* (re.union (re.range "\x00" "\x09") (re.range "\v" "\xff"))) (str.to.re "}") (re.* (re.range "\x00" "\xff")))) |IsMatch_/BS{.*BS}/_0|))
(assert (not |IsMatch_/BS{.*BS}/_0|))
(assert (= (str.in.re (ite (<= (str.len (elimWhiteRight (elimWhiteLeft Constructed_Argument))) 0) "" (elimWhiteRight (elimWhiteLeft Constructed_Argument))) (re.++ (re.* (re.range "\x00" "\xff")) (str.to.re "/") (re.* (str.to.re "/")) (re.* (re.range "\x00" "\xff")))) |IsMatch_/BS/+/_1|))
(assert (not |IsMatch_/BS/+/_1|))
(assert (not (<= (to_real (str.len (ite (<= (str.len (elimWhiteRight (elimWhiteLeft Constructed_Argument))) 0) "" (elimWhiteRight (elimWhiteLeft Constructed_Argument))))) 65536.0)))
(check-sat)
