\section{The string logic}

\subsection{Extended regular expressions}

A regular expression (with capturing group and back reference) is defined as follows.

\begin{definition}[Regular expressions with capturing group and back reference $\regexp$]
	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e)  , \]
	where $a \in \Sigma, n \in \Int^+$. 
	%	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. 
	%We use the abbreviation 
	$e^+$ abbreviates $e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we write $\Gamma \equiv a_1 + \cdots + a_k$ and $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 
\end{definition}
\zhilin{some sanity conditions should be put to make the semantics of $\$ n$ well-defined.}

Note that standard regular expressions are those without $\$ n$ or $(e)$.
%

Moreover, we use $\regexp[\sf CG]$ to denote the fragment of $\regexp$  excluding $\$ n$, and $\refexp$ to denote expressions generated by $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.
%\tl{define the semantics here?}

%\label{semantics:regex}



%\subsection{Semantics of \regexp[\sf CG]}
%In this section, we give one of the many semantics of \regexp[\sf CG], which we will utilize for $\replaceall$.

\begin{definition}[Subexpression]
	For any two $\regexp[\sf CG]$ $e$ and $r$, we say $r$ is a subexpression of $e$,
	if either $r=e$ or
	\begin{itemize}
		\item If $e = e_1 e_2$ or $e_1 + e_2$ then $r$ is a subexpression of $e_1$
		or $e_2$
		
		\item If $e = e_1^{\ast}$ or $(e_1)$ then $r$ is a subexpression of $e_1$
	\end{itemize}
	We use $S (e)$ to denote the set of all subexpressions of $e$.
\end{definition}


\begin{definition}[Match Tree]
	A \tmtextbf{match tree} of $\regexp[\sf CG]$ $e$ is a finite directed and ordered
	tree T, whose nodes are elements of $\Sigma^{\ast} \times S (e)$. A tree
	is valid if the root is $(w, e)$ for some string w, and for any node $u =
	(w, \alpha)$ in T, we have:
	\begin{itemize}
		\item If $\alpha = \alpha_1 \alpha_2$ then u has two children $(w_1,
		\alpha_1)$ and $(w_2, \alpha_2)$ where $w = w_1 w_2$.
		
		\item If $\alpha = \alpha_1 + \alpha_2$ then u has a single child $(w,
		\alpha_i)$ where $i \in \{ 1, 2 \}$.
		
		\item If $\alpha = \alpha_1^{\ast}$ then when $w = \varepsilon$, u is a
		leaf otherwise there is $k \geqslant 1$ such that u has k children $(w_1,
		\alpha_1), \ldots, (w_k, \alpha_1)$ where $w = w_1 \ldots w_k$ and for all
		$i \in [k]$, $w_i \neq \varepsilon$, even if $\varepsilon \in L
		(\alpha_1)$.
		
		\item If $\alpha = (\alpha_1)$ then u has a single child $(w, \alpha_1)$.
		
		\item If $\alpha = a$ (resp. $\alpha = \varepsilon$) then u is a leaf and
		$w = a$ (resp. $w = \varepsilon$).
	\end{itemize}
	
	Whenever unambiguous, we use a node u to represent the whole subtree
	where u is the root. The notation $C(T)$ refers to all direct children of the root node of T
	(and thus all direct subtrees).
	
	We also use $M (e)$ to denote all the valid match trees of e.
\end{definition}

\begin{definition}[Semantics of RegExp{[\sf CG]}]
	\
	
	For any $\regexp[\sf CG]$ e, we recursively define a total order on $M (e)$, written $m
	>_e n$ where $m, n \in M (e)$, as follows:
	\begin{itemize}
		\item $e = \varepsilon$ or $e = a$. There is only one match tree, thus the
		order $>_e$ is empty.
		
		\item $e = (e_1)$. Suppose $C (m) = (w_1, e_1)$ and $C (n) = (w_2, e_1)$,
		then $m >_e n$ iff $(w_1, e_1) >_{e_1} (w_2, e_1)$.
		
		\item $e = e_1 + e_2$.
		\begin{itemize}
			\item If $C (m) = (w, e_1)$ and $C (n) = (w', e_2)$, then $m >_e n$.
			
			\item If $C (m) = (w, e_i)$ and $C (n) = (w', e_i)$, where $i \in \{ 1,
			2 \}$, then $m >_e n$ iff $(w, e_i) >_{e_i} (w', e_i)$.
		\end{itemize}
		\item $e = e_1 e_2$. Suppose $C (m) = (w_1, e_1) (w_2, e_2)$ and $C (n) =
		(w_1', e_1) (w_2', e_2)$, then $m >_e n$ when either $(w_1, e_1) >_{e_1}
		(w_1', e_1)$, or $w_1 = w_1'$ and $(w_2, e_2) >_{e_2} (w_2', e_2)$.
		
		\item $e = e_1^{\ast}$. If n is a leaf but m is not, then $m >_e n$.
		Otherwise, suppose $C (m) = (w_1, e_1), \ldots, (w_k, e_1)$ and $C (n) =
		(w_1', e_1), \ldots, (w_l', e_1)$, we have $m >_e n$ either when $C (n)$
		is a proper prefix of $C (m)$, or for the first index j such that $w_j
		\neq w_j'$, $(w_j, e_1) >_{e_1} (w_j', e_1)$.
	\end{itemize}
	
	Let $e \in \regexp[\sf CG]$, and string $w \in L (e)$, then the accepting match of w
	on e, denoted by $m_e (w)$, is the supremum of the set $\{ m \in M (e) \mid m = (w, e) \}$.
	
	For any subexpression $e'$ of e, suppose $(w_1, e') \ldots (w_m, e')$ are
	all the nodes labeled by $(w', e')$, where $w' \neq \varepsilon$, in the
	pre-order traversal of $m_e (w)$. Then the match result captured by $e'$, denoted
	by $m_{e', e} (w)$, is the sequence of substring $w_1 \ldots w_m$.
\end{definition}

\zhilei{Give an example here}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%We will use $\$ 1, \$2, \cdots$ to denote the references to capturing groups in regular expressions.

%We define the set of reference expressions as follows: 


\begin{definition}[The constraint language $\strline$] 
The constraint language $\strline$ is defined by
\[
\begin{array}{l c l}
S &::= &  z:= x\ \concat\ y \mid z := \replaceall_{\pat, \rep}(x)   \mid \\ 
& &  y := \reverse(x) \mid y := \Transducer(x)\ |\  \text{$\ASSERT{x \in e}$}\ |\ S; S\
\label{eq:SL}
%a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n)
\end{array}
\]
\tl{to avoid confusion, write  $\ASSERT{x \in A}$?} 
where $\concat$ is the string concatenation operation which concatenates two strings, $\pat\in \regexp[\sf CG]$, $\rep \in \refexp$, $e \in \regexp$, %$\replaceall$ is the replace-all function to be defined shortly,
$\reverse$ is the string function which reverses a string, and $\Transducer$ is a \PSST.  
%and $R$ is a recognisable relation represented by a collection of tuples of \FA{}s.
\end{definition}
\zhilei{Should we add NSST constraints? Basically NSST can express more than PSST.}
\tl{maybe just use NSST to replace PSST?}

\zhilei{PSST is needed for decision procedure. NSST can be decided too, but the algorithm is very similar, so maybe too tedious to add both }

It is evident that the $\reverse$ function is subsumed by \PSST{}s.


\begin{remark}
	Zhilin mentioned that we might introduce a function which takes a string and a pattern with capturing groups, and does sort of pattern matching to extra substrings. This function can be captured by the transducer $T$. We will formalise this later.
\end{remark}

\subsection{Undecidability: Regular expressions with capturing groups and back references}

$\strline$ is in general undecidable, as a result of the back references.

\zhilin{Decidable fragments? Could we assume that the assertions $\ASSERT{x \in e'}$ where $e'$ contains back references are only for the input variables ?}

