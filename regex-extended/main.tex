%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].

\input{macros.tex}

\usepackage{mathrsfs}

\newif\ifdraft\drafttrue
%\newif\ifdraft\draftfalse
\ifdraft
\newcommand{\anthony}[1]{\color{red} {AL: #1 :LA} \color{black}}
\newcommand{\zhilin}[1]{\color{brown} {ZL: #1 :LZ} \color{black}}
\newcommand{\tl}[1]{\color{blue} {TL: #1 :LT} \color{black}}
\newcommand{\mat}[1]{\color{cyan} {MH: #1 :HM} \color{black}}
\newcommand{\philipp}[1]{\color{magenta} {PR: #1 :PR} \color{black}}
\newcommand{\zhilei}[1]{\color{green} {PR: #1 :PR} \color{black}}
\else
\newcommand{\anthony}[1]{}
\newcommand{\zhilin}[1]{}
\newcommand{\tl}[1]{}
\newcommand{\mat}[1]{}
\newcommand{\zhilei}[1]{}
\fi

%%%%%%%%%% Start TeXmacs macros
\newcommand{\colons}{\,:\,}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newtheorem{definition}{Definition}
%{\theorembodyfont{\rmfamily}\newtheorem{note}{Note}}
%{\theorembodyfont{\rmfamily}\newtheorem{remark}{Remark}}
\newtheorem{theorem}{Theorem}
\newtheorem{note}{Note}
\newtheorem{remark}{Remark}
%%%%%%%%%% End TeXmacs macros



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}

%% Title information
\title{Solving String Constraints with \\ Practical Regular Expressions}



%% Author with single affiliation.
\author{Taolue Chen}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{}
%  \department{}              %% \department is recommended
  \institution{Birkbeck, University of London}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{London}
%  \state{UK}
%  \postcode{Post-Code1}
  \country{UK}                    %% \country is recommended
}
\email{taolue.chen@gmail.com}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Zhilin Wu}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \department{State Key Laboratory of Computer Science}             %% \department is recommended
  \institution{Institute of Software, Chinese Academy of Sciences}           %% \institution is required
%  \streetaddress{Street2a Address2a}
  \city{Beijing}
%  \state{State2a}
%  \postcode{Post-Code2a}
  \country{China}                   %% \country is recommended
}
\email{wuzl@ios.ac.cn}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\newcommand\NSST{{\sf NSST}}

\newcommand\refexp{{\sf REF}}



\section{Introduction}

Streaming String Transducers: \cite{FR17}

\section{Preliminaries}

$\Int^+$ is the set of integers. 

\begin{definition}[Streaming String Transducer]
  A nondeterministic streaming string transducer (\NSST) is a tuple $T = (Q, \Sigma, X, E, q_0, F)$, where $Q$ is a finite set of states, $\Sigma$ is both the input alphabet and the output alphabet, $X$ is a finite set of string variables, $E \subseteq Q \times \Sigma \times Q \times S$ is a finite set of
  transition rules where $S$ is a set of assignment functions from $X$ to $(X
  \cup \Sigma)^{\ast}$, and $F$ is the output function, which is a partial function from $Q$ to $(X \cup
  \Sigma)^{\ast}$.
  \end{definition}
  
  A run $r$ of $T$ on a string $w = \sigma_1 \ldots \sigma_n$ is $q_0 \xrightarrow{\sigma_1 / s_1} q_1
  \xrightarrow{\sigma_2 / s_2} \ldots \xrightarrow{\sigma_n / s_n} q_n$ such that
  $(q_i, \sigma_{i + 1}, q_{i + 1}, s_{i + 1}) \in E$ for $1 \le i < n$. A run $r$ is \emph{successful} if $F(q_n)$ is
  defined. 
  %
  The output of a run $r$ of $T$ on $w$, denoted by $T_r(w)$, is defined as $\pi_n(F(q_n))$, where $\pi_0(x) = \varepsilon$ for each $x \in X$, and $\pi_{i}(x) = \pi_{i-1}(s_{i}(x))$ for $1 \le i \le n$ and $x \in X$. Note that here we abuse the notation in $\pi_n(F(q_n))$ and $\pi_{i-1}(s_{i}(x))$ by taking a function $\pi$ from $X$ to $\Sigma^*$ as a function from $(X \cup \Sigma)^*$ to $\Sigma^*$, which maps each $\sigma \in \Sigma$ to $\sigma$ and each $x \in X$ to $\pi(x)$.  
  
%  $\tmop{Out} (r) =
%  s_{\varepsilon} \circ s_1 \circ s_2 \ldots s_n \circ F (q_n)$ where
%  $s_{\varepsilon}$ is the empty substitution which maps all variables to
%  $\varepsilon$.
  
The set of outputs of $T$ on a string $w$, denoted by $T(w)$, is defined as $\{ T_r(w) \mid  r
\mbox{ is a successful run of } T \mbox{ on } w \}$.

Note that in the definition of \NSST, there is no \emph{copyless} restriction.

\section{The string logic}


A regular expression with capturing group is defined as follows.

\begin{definition}[Regular expressions  with capturing groups and back references $\regexp$]
	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e), \mbox{ where } a \in \Sigma, n \in \Int^+. \]
%	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. 
%We use the abbreviation 
$e^+$ abbreviates $e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we write $\Gamma \equiv a_1 + \cdots + a_k$ and $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 
\end{definition}
\zhilin{some sanity conditions should be put to make the semantics of $\$ n$ well-defined.}

Note that the standard regular expressions are those defined by the aforementioned rules with $\$ n$ and $(e)$ removed.
Moreover, for convenience, we use $\regexp[\sf CG]$ to denote the subclass of $\regexp$ where the rule $\$ n$ is removed. We also use $\refexp$ to denote the set of reference expressions, namely, the expressions defined by the rules $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.


%We will use $\$ 1, \$2, \cdots$ to denote the references to capturing groups in regular expressions.

%We define the set of reference expressions as follows: 


%\begin{definition}[The constraint language $\strline$]%
The constraint language $\strline$ is defined by the following rules,
\[
\begin{array}{l c l}
S &::= &  z:= x\ \concat\ y \ |\ z := \replaceall_{e_1, e_2}(x) \ | \  y := \reverse(x) \ |\ \\
& &  y := \Transducer(x)\ |\  \text{$\ASSERT{R(\vec{x})}$}\ |\ S; S\
\label{eq:SL}
%a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n)
\end{array}
\]
where $\concat$ is the string concatenation operation which concatenates two strings, $e_1 \in \regexp[\sf CG]$ and $e_2 \in \refexp$, %$\replaceall$ is the replace-all function to be defined shortly,
$\reverse$ is the string function which reverses a string, $\Transducer$ is a \NSST{},  and $R$ is a recognisable relation represented by a collection of tuples of \FA{}s.


It is evident that the $\reverse$ function is subsumed by \NSST{}s.


\section{Decision procedures}


\subsection{Regex with capturing groups}

\subsection{Regex with capturing groups and back references}

\subsection{$\replaceall$ with capturing groups and references}


\begin{theorem}[PreImage]
  Given NSST $T = (Q_T, \Sigma, \Sigma', \Gamma, E, q_{0, T}, F_T)$ and NFA $M
  = (Q_M, \Sigma', \delta_M, q_{0, M}, F_M)$, there is an NFA $N = (Q_N,
  \Sigma, \delta_N, q_{0, N}, F_N)$, such that for all word w on $\Sigma$, $w
  \in L (N)$ if and only if there is a word $w' \in T (w)$ such that $w' \in L
  (M)$. N is computable from T and M.
\end{theorem}

We omit the correctness proof for now, but give a construction of N:

\

Let $Q_N = Q_T \times P (Q_M)^{Q_M \times \Gamma}$, thus the state of N is
denoted by a pair $(q, \rho)$ where q is a state of T and $\rho \in Q_M \times
\Gamma \rightarrow P (Q_M)$ is the simulation function. The initial state of N
is $(q_{0, T}, \rho_{\varepsilon})$ where $\rho_{\varepsilon} (q, x) = \{ q
\}$ for all state q and variable x.

For a state $q \in Q_M$, a simulation function $\rho$, and a string $w \in
(\Gamma \cup \Sigma')^{\ast}$, we recursively define the \tmtextit{evaluation}
of w on q and $\rho$, denoted by $U (q, \rho, w)$ as
\[ U (q, \rho, w) = \left\{ \begin{array}{ll}
     \delta_M^{\ast} (U (q, \rho, w'), a) & w = w' a \wedge a \in \Sigma'\\
     \bigcup_{q' \in U (q, \rho, w')} \rho (q', a) & w = w' a \wedge a \in
     \Gamma\\
     \{ q \} & w = \varepsilon
   \end{array} \right. \]
For all substitution $s \in \Gamma \rightarrow (\Gamma \cup \Sigma')^{\ast}$,
the simulation function $\rho$ \tmtextit{updated} by s, denoted by $R (\rho,
s)$, is another simulation function defined as follows:
\[ R (\rho, s) (q, x) = U (q, \rho, s (x)) \]
Now, consider the transition function of N. For all state $(q, \rho) \in Q_N$,
if $(q, a, q', s) \in E$ for some character a and substitution s, then:
\[ ((q, \rho), a, (q', R (\rho, s))) \in \delta_N \]
At last, the terminal state set $F_N$ contains all the states $(q, \rho)$
which satisfy the following properties:
\begin{enumerate}
  \item $F_T (q)$ is defined
  
  \item $U (q_{0, M}, \rho, F_T (q)) \cap F_M \neq \emptyset$
\end{enumerate}


\begin{note}[Intuition]
  The construction above is actually very simple. The automaton N simulates
  the run of NSST T, together with the \tmtextit{summary} of M when a variable
  of T in inputed. The construction should be exponential.
  
  The construction does not use the so-called \tmtextit{copyless}
  property{\cite{AC10,AD11}},
  thus the expressive power of NSST in this context is greater than 2FT.
\end{note}

\

\begin{definition}[Two way NSST?]
  The definition of 2NSST is just like 2FT, allowing bidirectional move of
  NSST's head.
\end{definition}

\begin{note}
  \
  
  One thing is worth noting about this idea of 2NSST: \tmtextit{the pre-image
  of 2NSST is still computable}. We just use a 2FA N to simulate the 2NSST, in
  the same manner of the construction above. We can then transform the 2FA
  into a one-way FA in exponential time.
  
  However, the expressive power of 2NSST is unknown (yet). I highly suspect
  that 2NSST is equivalent to NSST, since the bidirectional move of head
  provides the same function as variables, to some extent. Anyway, the
  expressive power of NSST should be sufficient now.
\end{note}

\

All the function expressible by 2FT is also expressible by NSST, like
\tmtextit{split}. Below is an example of what more NSST can express.

\begin{definition}[Regular Expression with capturing group, regex]
  Suppose $\Gamma$ is some set of variables, x is an element of $\Gamma$. a is
  a character in $\Sigma$
  \[ \alpha \colons = \varepsilon |a| \alpha + \alpha | \alpha \circ \alpha |
     \alpha^{\ast} | (\alpha) \%x \]
  WLOG, we assume a variable occurs at most once in a regex.
  
  the semantics of regex is defined as tuple $(w, w_x, w_y, \ldots)$ where w
  is the whole string matched, and $w_x$ is the string matched by the
  capturing group marked by x, etc. A more formal definition involves match
  trees and recursive definition.
  See{\cite{CSY03,CN09}}
\end{definition}

\begin{definition}[ReplaceAll with capturing group and back reference]
  Consider the constriant $y = \tmop{replaceAll} (x, e, r)$, where e is a
  regex and $r \in (\Sigma \cup \Gamma)^{\ast}$.
  
  The semantics of replaceAll in this form is like the original
  one{\cite{CCH+18}}, with leftmost and longest match of
  e in x replaced, except that when replacing, every variable in r is
  substituted by the string captured by the corresponding capturing group in
  e.
  
  A more formal definition should be proposed in the future.
\end{definition}

\begin{note}
  \
  
  The capturing process might not be unique, though. For example, $(a^+) \%x
  (a^+) \%y$ matches any string $a^n$ with n greater than 1, but the match
  over string 'aaa' has two possibilities ('aa' for x, or 'a' for x).
  
  Thus, this form of replaceAll becomes nondeterministic.
\end{note}

\

\begin{remark}
  Given e and r, we could use NSST to model this function.
\end{remark}

Again, we give a construction of NSST, but omit the proof:

\

Suppose A=$(Q, F, \delta, \Sigma, q_0)$ is the NFA constructed by Glushkov
method on e. Here, $Q = \{ q_0, q_1, \ldots, q_n \}$. Each state other than
$q_0$ corresponds to an occurrence of character in e.

For every subexpression v of e, by the definition of Glushkov construction,
there must be a subgraph of A which corresponds to v. Use A(v) to denote the
subgraph. For a state q of A, define $\Gamma (q) = \{ x \in \Gamma |v
\tmop{is} a \tmop{capturing} \tmop{group} \tmop{of} x \tmop{in} e \wedge q \in
A (v) \}$, in other words, $\Gamma (q)$ is the set of variables which should
be updated when entering q.

Furthermore, for a subexpression v, we use Start(v) and End(v) to denote the
starting and ending states of A(v) (see the definition of Glushkov
construction).

\

Let NSST $T = (Q', \Sigma, \Sigma, \{ \tmop{acc} \} \cup \Gamma, E, q_0',
F')$, we construct T using a similar method as parsing
automata{\cite{chenWhatDecidableString2018}}. The initial state is $(\{ q_0
\}, \tmop{left}, \emptyset)$.
\begin{itemize}
  \item The transition within \tmtextit{left} mode is just the same as the
  original parsing automata. The substitution is s(acc)=acc.a and s(x)=x for
  every x other than acc, where a is the input character in this step.
  
  \item Suppose $(\rho \{ q_0 \}, \tmop{left}, S) \in Q'$, and $a \in \Sigma$.
  If $\delta (S, a) \cap F = \emptyset$, $\delta^{\ast} (\rho, a) \cap F =
  \emptyset$ and $\delta (q_0, a) \nsubseteq \delta (S, a) \cup \delta^{\ast}
  (\rho, a)$, then for every $q' \in \delta (q_0, a)$, we have
  \[ ((\rho \{ q_0 \}, \tmop{left}, S), a, (\{ q' \}, \tmop{long}, \delta (S,
     a) \cup \delta^{\ast} (\rho, a)), s) \in E \]
  where s is the substitution defined as: s(x) = x.a for every x in $\Gamma
  (q')$, and s(y)=y for every other variable y.
  
  \item Suppose $(\{ q \}, \tmop{long}, S) \in Q'$, and $a \in \Sigma$. If
  $\delta (S, a) \cap F = \emptyset$, and \ $\delta (q, a) \nsubseteq \delta
  (S, a)$, then for every $q' \in \delta (q_0, a)$, we have
  \[ ((\{ q \}, \tmop{long}, S), a, (\{ q' \}, \tmop{long}, \delta (S, a)), s)
     \in E \]
  where s is defined as follows:
  
  Suppose $V = \{ v|v \tmop{is} a \tmop{Kleene} \tmop{star} \tmop{in} e \wedge
  q \in \tmop{End} (v) \wedge q' \in \tmop{Start} (v) \}$. Let P be the set of
  all variables captured in V. For all variable x in the set $\Gamma (q')
  \backslash P$, s(x)=acc.a. For all variable y in the set $P\backslash \Gamma
  (q')$, $s (x) = \varepsilon$. For all variable z in the set $P \cap \Gamma
  (q')$, s(z)=a. All the other variables do not change.
  
  \item Suppose $(\{ q \}, \tmop{long}, S) \in Q'$, and $a \in \Sigma$. If
  $\delta (S, a) \cap F = \emptyset$ and $\delta (q, a) \cap F \neq
  \emptyset$, then for every state $q' \in \delta (q, a) \cap F$, we have
  \[ ((\{ q \}, \tmop{long}, S), a, (\{ q_0 \}, \tmop{left}, \delta (S, a)
     \cup q'), s) \in E \]
  where s is defined as: $s (\tmop{acc}) = \tmop{acc} .a_1 .a_2 \ldots a_n$,
  where $r = a_1 \ldots a_n$. $s (x) = \varepsilon$ for every other variable
  x.
\end{itemize}
The output function $F'$ is simple: $F' (q) = \tmop{acc} \quad \tmop{iff}
\quad q = (-, \tmop{left}, -) $.

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
\bibliography{string}

%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots


\end{document}
