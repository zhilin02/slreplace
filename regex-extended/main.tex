%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].

\input{macros.tex}

\usepackage{mathrsfs}

\newif\ifdraft\drafttrue
%\newif\ifdraft\draftfalse
\ifdraft
\newcommand{\anthony}[1]{\color{red} {AL: #1 :LA} \color{black}}
\newcommand{\zhilin}[1]{\color{brown} {ZL: #1 :LZ} \color{black}}
\newcommand{\tl}[1]{\color{blue} {TL: #1 :LT} \color{black}}
\newcommand{\mat}[1]{\color{cyan} {MH: #1 :HM} \color{black}}
\newcommand{\philipp}[1]{\color{magenta} {PR: #1 :PR} \color{black}}
\newcommand{\zhilei}[1]{\color{green} {PR: #1 :PR} \color{black}}
\else
\newcommand{\anthony}[1]{}
\newcommand{\zhilin}[1]{}
\newcommand{\tl}[1]{}
\newcommand{\mat}[1]{}
\newcommand{\zhilei}[1]{}
\fi

%%%%%%%%%% Start TeXmacs macros
\newcommand{\colons}{\,:\,}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newtheorem{definition}{Definition}
%{\theorembodyfont{\rmfamily}\newtheorem{note}{Note}}
%{\theorembodyfont{\rmfamily}\newtheorem{remark}{Remark}}
\newtheorem{theorem}{Theorem}
%\newtheorem{note}{Note}
\newtheorem{remark}{Remark}
\newcommand\NSST{{\sf NSST}}
\newcommand\refexp{{\sf REF}}
\newcommand\ssym{{\sf Start}}
\newcommand\esym{{\sf End}}
%%%%%%%%%% End TeXmacs macros




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}

%% Title information
\title{Solving String Constraints with Practical Regular Expressions}



%% Author with single affiliation.
\author{Taolue Chen}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{}
%  \department{}              %% \department is recommended
  \institution{Birkbeck, University of London}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{London}
%  \state{UK}
%  \postcode{Post-Code1}
  \country{UK}                    %% \country is recommended
}
\email{taolue.chen@gmail.com}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Zhilin Wu}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \department{State Key Laboratory of Computer Science}             %% \department is recommended
  \institution{Institute of Software, Chinese Academy of Sciences}           %% \institution is required
%  \streetaddress{Street2a Address2a}
  \city{Beijing}
%  \state{State2a}
%  \postcode{Post-Code2a}
  \country{China}                   %% \country is recommended
}
\email{wuzl@ios.ac.cn}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Streaming String Transducers: \cite{FR17}

\section{Prelimiaries}


\begin{definition}[Finite-state automata] \label{def:nfa}
	A \emph{(nondeterministic) finite-state automaton}
	(\FA{}) over a finite alphabet $\ialphabet$ is a tuple $\Aut =
	(\ialphabet, \controls, q_0, \finals, \transrel)$ where 
	$\controls$ is a finite set of 
	states, $q_0\in \controls$ is
	the initial state, $\finals\subseteq \controls$ is a set of final states, and 
	$\transrel\subseteq \controls \times 
	\ialphabet \times  \controls$ is the
	transition relation. 
\end{definition}

For an input string $w = a_1 \dots a_n$, a \emph{run} of $\Aut$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a sequence of states $q_0,\ldots, q_n$ such that $(q_{j-1}, a_{j}, q_{j}) \in
\transrel$  for every $j \in [n]$.
The run is said to be \defn{accepting} if $q_n \in \finals$.
A string $w$ is \defn{accepted} by $\Aut$ if there is an accepting run of
$\Aut$ on $w$. In particular, the empty string $\varepsilon$ is accepted by $\Aut$ iff $q_0 \in F$. The set of strings accepted by $\Aut$ is denoted by $\Lang(\Aut)$,
a.k.a., the language \defn{recognised} by $\Aut$.
%Since we deal with computational complexity in the sequel, we define
The \defn{size} $|\Aut|$ of $\Aut$ is defined to be $|\controls|$; we will
use this when we discuss computational complexity.

For convenience, for $a \in \Sigma$, we use $\delta^{(a)}$ to denote the  relation $\{(q, q') \mid (q, a, q') \in \delta\}$.


\begin{definition}[Streaming String Transducer]
  A nondeterministic streaming string transducer (\NSST) is a tuple $T = (Q, \Sigma, X, E, q_0, F)$, where $Q$ is a finite set of states, $\Sigma$ is both the input alphabet and the output alphabet, $X$ is a finite set of variables, $E \subseteq Q \times \Sigma \times Q \times S$ is a finite set of
  transition rules where $S$ is the set of assignment functions, namely functions from $X$ to $(X
  \cup \Sigma)^{\ast}$, and $F$ is the output function, which is a partial function from $Q$ to $(X \cup
  \Sigma)^{\ast}$.
  \end{definition}
  
  A run $r$ of $T$ on a string $w = \sigma_1 \ldots \sigma_n$ is $q_0 \xrightarrow{\sigma_1 / s_1} q_1
  \xrightarrow{\sigma_2 / s_2} \ldots \xrightarrow{\sigma_n / s_n} q_n$ such that
  $(q_i, \sigma_{i + 1}, q_{i + 1}, s_{i + 1}) \in E$ for every $i: 1 \le i < n$. A run $r$ is \emph{successful} if $F(q_n)$ is
  defined. The output of a run $r$ of $T$ on $w$, denoted by $T_r(w)$, is defined as $\pi_n(F(q_n))$, where $\pi_0(x) = \varepsilon$ for each $x \in X$, and $\pi_{i}(x) = \pi_{i-1}(s_{i}(x))$ for each $i: 1 \le i \le n$ and $x \in X$. Note that here we abuse the notation in $\pi_n(F(q_n))$ and $\pi_{i-1}(s_{i}(x))$ by taking a function $\pi$ from $X$ to $\Sigma^*$ as a function from $(X \cup \Sigma)^*$ to $\Sigma^*$, which maps each $\sigma \in \Sigma$ to $\sigma$ and each $x \in X$ to $\pi(x)$.  
  
%  $\tmop{Out} (r) =
%  s_{\varepsilon} \circ s_1 \circ s_2 \ldots s_n \circ F (q_n)$ where
%  $s_{\varepsilon}$ is the empty substitution which maps all variables to
%  $\varepsilon$.
  
The set of outputs of $T$ on a string $w$, denoted by $T(w)$, is defined as $\{ T_r(w) | r
\mbox{ is a successful run of } T \mbox{ on } w \}$. For an \NSST{} $T$, we use $\cR_T$ to denote the string relation $\{(w, w') \mid w' \in T(w)\}$.

For a string relation $R \subseteq \Sigma^* \times \Sigma^*$ and $L \subseteq \Sigma^*$, we define the \emph{pre-image} of $L$ under $R$, denoted by $R^{-1}(L)$, as $\{w \in \Sigma^* \mid \exists w'.\ w' \in L \mbox{ and } (w, w') \in R\}$. 

Note that in the definition of \NSST{}s, we do \emph{not} put the  \emph{copyless} restriction on them.

\section{The string logic}


A regular expression with capturing group is defined as follows.

\begin{definition}[Regular expressions $\regexp$ with capturing groups and back references]
	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid \$n \mid e + e \mid e \concat e \mid e^* \mid (e), \mbox{ where } a \in \Sigma, n \in \Int^+. \]
	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. We use the abbreviation $e^+ \equiv e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_k\}\subseteq \Sigma$, we use the abbreviations $\Gamma \equiv a_1 + \cdots + a_k$ and $\Gamma^\ast \equiv (a_1 + \cdots + a_k)^\ast$. 
\end{definition}
\zhilin{some sanity conditions should be put to make the semantics of $\$ n$ well-defined.}

Note that the standard regular expressions are those defined by the aforementioned rules with $\$ n$ and $(e)$ removed.
Moreover, for convenience, we use $\regexp[\sf CG]$ to denote the subclass of $\regexp$ where the rule $\$ n$ is removed. We also use $\refexp$ to denote the set of reference expressions, namely, the expressions defined by the rules $e \eqdef \varepsilon \mid a \mid \$n \mid e \concat e$.


%We will use $\$ 1, \$2, \cdots$ to denote the references to capturing groups in regular expressions.

%We define the set of reference expressions as follows: 


\begin{definition}[The constraint language $\strline$]%
The constraint language $\strline$ is defined by the following rules,
\[
\begin{array}{l c l}
S &::= &  z:= x\ \concat\ y \ |\ z := \replaceall_{e_1, e_2}(x) \ | \  y := \reverse(x) \ |\ \\
& &  y := \Transducer(x)\ |\  \text{$\ASSERT{x \in e'}$}\ |\ S; S\
\label{eq:SL}
%a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n)
\end{array}
\]
where $\concat$ is the string concatenation operation which concatenates two strings, $e_1 \in \regexp[\sf CG]$, $e_2 \in \refexp$, $e' \in \regexp$, %$\replaceall$ is the replace-all function to be defined shortly,
$\reverse$ is the string function which reverses a string, and $\Transducer$ is an \NSST{}.  
%and $R$ is a recognisable relation represented by a collection of tuples of \FA{}s.
\end{definition}

It is evident that the $\reverse$ function is subsumed by \NSST{}s.


\section{Decision procedures}


\subsection{Regular expressions with capturing groups}

semantics captured by prioritized transducers, \cite{BM17}.

\subsection{Regular expressions with capturing groups and back references}

$\strline$ is in general undecidable, as a result of the back references.

\zhilin{Decidable fragments? Could we assume that the assertions $\ASSERT{x \in e'}$ where $e'$ contains back references are only for the input variables ?}

\subsection{$\replaceall$ with capturing groups and references}

\begin{theorem}[Pre-image of \NSST{}]
  Given an \NSST{} $T = (Q_T, \Sigma$, $X, E, q_{0, T}, F_T)$ and \FA{} $A
  = (Q_A, \Sigma, \delta_A, q_{0, A}, F_A)$, we can compute in exponential time an \FA{} $B = (Q_B,
  \Sigma, \delta_B, q_{0, B}, F_B)$ such that $\Lang(B) = \cR^{-1}_T(L)$. 
\end{theorem}

%We omit the correctness proof for now, but give a construction of N:
%
%\
\begin{proof}
Intuitively, $B$ simulates the run of $T$ on $w$, and records  for each $x \in X$ the set of state pairs $(p, q) \in Q_A \times Q_A$ such that starting from $p$, $A$ can reach $q$ after reading the string represented by $x$.

Formally, $Q_B = Q_T \times (\cP(Q_A \times Q_A ))^{X}$, $q_{0, B} = (q_{0, T}, \rho_{\varepsilon})$ where $\rho_{\varepsilon} (x) = \{(q, q) \mid q \in Q\}$ for each $x \in X$, and $\delta_{B}$ comprises the tuples $((q, \rho), a, (q', \rho'))$ such that there exists $s \in \left((X \cup \Sigma\right)^*)^X$ satisfying
\begin{itemize}
\item $(q, a, q', s) \in \delta_T$, 
\item and $\rho'$ is obtained from $\rho$ and $s$ as follows: for each $x \in X$, if $s(x) = \varepsilon$, then $\rho'(x) = \{(p, p) \mid p \in Q_A\}$, otherwise, let $s(x) = b_1 \cdots b_\ell$ with $b_i \in \Sigma \cup X$ for each $i \in [\ell]$, then $\rho'(x) = \theta_1 \circ \cdots \circ \theta_\ell$, where $\theta_i = \delta^{(b_i)}_A$ if $b_i \in \Sigma$, and $\theta_i = \rho(b_i)$ otherwise.
%
%$\rho'(x) = \theta_\ell$ such that $\theta_0 = \{(p,p) \mid p \in Q_A\}$, and for each $i \in [\ell]$, if $b_i \in \Sigma$, then $\theta_i = \{(p, p') \mid (p, p'') \in \theta_{i-1}, (p'', b_i, p') \in \delta_A \mbox{ for some } p''\}$, otherwise, $\theta_i = \theta_{i-1} \cdot \rho(x)$. 
\end{itemize}

Moreover, $F_B$ is the set of states $(q, \rho) \in Q_B$
such that
\begin{enumerate}
  \item $F_T (q)$ is defined,
  
  \item if $F_T(q) = \varepsilon$, then $q_{0, A}  \in F_A$, otherwise, 
let $F_T(q) = b_1 \cdots b_\ell$ with $b_i \in \Sigma \cup X$ for each $i \in [\ell]$, then $(\theta_1 \circ \cdots \circ \theta_\ell) \cap (\{q_{0,A}\} \times F_A) \neq \emptyset$, where for each $i \in [\ell]$, if $b_i \in \Sigma$, then $\theta_i = \delta^{(b_i)}_A$, otherwise, $\theta_i = \rho(b_i)$.
\end{enumerate}
\end{proof}

\begin{remark}
%  The construction above is actually very simple. The automaton N simulates
%  the run of NSST T, together with the \tmtextit{summary} of M when a variable
%  of T in inputed. The construction should be exponential.
%  
  The construction does not utilize the so-called \tmtextit{copyless}
  property in {\cite{AC10,AD11}},
  thus the construction works for \emph{copyful} \NSST{} used in this paper.
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
\begin{definition}[Two way NSST?]
  The definition of 2NSST is just like 2FT, allowing bidirectional move of
  NSST's head.
\end{definition}

\begin{note}
  \
  
  One thing is worth noting about this idea of 2NSST: \tmtextit{the pre-image
  of 2NSST is still computable}. We just use a 2FA N to simulate the 2NSST, in
  the same manner of the construction above. We can then transform the 2FA
  into a one-way FA in exponential time.
  
  However, the expressive power of 2NSST is unknown (yet). I highly suspect
  that 2NSST is equivalent to NSST, since the bidirectional move of head
  provides the same function as variables, to some extent. Anyway, the
  expressive power of NSST should be sufficient now.
\end{note}

All the function expressible by 2FT is also expressible by NSST, like
\tmtextit{split}. Below is an example of what more NSST can express.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{definition}[Regular Expression with capturing group, regex]
%  Suppose $\Gamma$ is some set of variables, x is an element of $\Gamma$. a is
%  a character in $\Sigma$
%  \[ \alpha \colons = \varepsilon |a| \alpha + \alpha | \alpha \circ \alpha |
%     \alpha^{\ast} | (\alpha) \%x \]
%  WLOG, we assume a variable occurs at most once in a regex.
  
%  the semantics of regex is defined as tuple $(w, w_x, w_y, \ldots)$ where w
%  is the whole string matched, and $w_x$ is the string matched by the
%  capturing group marked by x, etc. A more formal definition involves match
%  trees and recursive definition.
%  See{\cite{CSY03,CN09}}
%\end{definition}

\begin{definition}[Semantics of $\replaceall_{e_1, e_2}$]
  Consider the constriant $y = \replaceall_{e_1, e_2}(x)$, where $e_1 \in \regexp[\sf CG]$ and $e_2 \in \refexp$.
  
The semantics of $\replaceall_{e_1, e_2}$ is  similar to that in {\cite{CCH+18}}, where the leftmost and longest matching of
  $e_1$ in $x$ is considered, with the difference that here the replacement string is obtained from a matching of $e_1$ by replacing every reference $\$ n$ in $e_2$ with the string matched by the subexpression corresponding to the $n$-th capturing group.
%  
\zhilin{A more formal definition should be added in the future.}
\end{definition}

\begin{remark}
  In the aforementioned definition of the semantics of $\replaceall_{e_1,e_2}(x)$, even though the matching of $e_1$ in $x$ is deterministic since the leftmost and longest matching is considered, the matchings of the subexpressions may not be deterministic. For instance, although the leftmost and longest matching of $e_1 = (a^+) 
  (a^+) $ in $a^3b$ is $a^3$, the matching of the first and the second capturing group could be either $aa$ and $a$, or $a$ and $aa$.
  
Therefore, the semantics of $\replaceall_{e_1,e_2}(x)$ can be seen as an approximation of that used in programming languages, e.g. Javascript, which can be seen as a tradeoff. \zhilin{this tradeoff should be justified}
\end{remark}

\zhilin{Could we unify prioritized transducers and streaming transducers to capture faithfully the semantics of $\replaceall_{e_1,e_2}(x)$ ?}

\begin{theorem}
  For each $e_1 \in \regexp[\sf CG]$ and $e_2 \in \refexp$, $\replaceall_{e_1, e_2}$ can be modeled by a $\NSST${} $T_{e_1,e_2}$.
\end{theorem}

\begin{proof}
Suppose that $A_{e_1} =(Q, \Sigma,  \delta, q_0, F)$ is the Glushkov automaton \cite{Gluskov61} constructed from $e_1 \in \regexp[\sf CG]$. From the Glushkov
construction, we know that $Q$ is the union of the initial state $q_0$ and the set of $a_i$'s where the $i$-th character occurring in $e$ is $a$. For instance, if $e_1 = (a (ab)^*)^*$, then we consider the marked regular expression $(a_1 (a_2 b_3)^*)^*$, and let $Q = \{q_0, a_1, a_2, b_3\}$, $F = \{q_0, a_1, b_3\}$, and $\delta = \{(q_0, a, a_1), (a_1, a, a_2)$, $(a_1, a, a_1), (a_2, b, b_3), (b_3, a, a_2), (b_3, a, a_1)\}$. 
%Each state other than $q_0$ corresponds to an occurrence of character in e.

For each subexpression $e'$ of $e_1$, let us use $C_{e'}$ to denote the set of subexpressions of $e'$ corresponding to a capturing group in $e'$.
For every subexpression $e'$ of $e_1$, from the Glushkov construction,
there must be a unique subgraph of $A_{e_1}$ corresponding to $e'$, denoted by $A_{e_1}[e']$. For instance, if $e_1 = (a (ab)^*)^*$ and $e' = a(ab)^*$, then $A_{e_1}[a(ab)^*]$ is the subgraph of $A_{e_1}$ comprising the states $\{a_1, a_2, b_3\}$ and the transitions $\{(a_1, a, a_2), (a_2, b, b_3), (b_3, a, a_2)\}$.
For each state $a_i$ of $A_{e_1}$, define $C(a_i)$  as the set $\{ e' \in C_{e_1} \mid a_i \mbox{ is a vertex in }
A_{e_1}[e']\}$. Intuitively, $C(a_i)$ represents the set of subexpressions in $C_{e_1}$ whose values should be updated when entering the state $a_i$ in $A_{e_1}$. Moreover, for each $e' \in C_{e_1}$, we use $\ssym(e')$ (resp. $\esym(e')$) to denote the set of marked symbols that can be matched to the first  (resp. last) symbol of a string matching $e'$. For instance, let $e' = a(ab)^*$, then $\ssym(e') = \{a_1\}$ and $\esym(e') = \{a_1, b_3\}$. 
%other words, $\Gamma (q)$ is the set of variables which should
%be updated when entering q.

For each $e' \in C_{e_1}$, we introduce a string variable $x_{e'}$. Moreover, we introduce another string variable $x_{res}$ to denote the result of $\replaceall_{e_1,e_2}$. Let $X$ denote the set of these string variables.
Then we construct the \NSST{} $T_{e_1,e_2} = (Q', \Sigma, X, E, q_0', F')$, by using the idea of parsing automata in \cite{CCH+18} as follows: At first, $q'_0= (\{ q_0
\}, \tmop{left}, \emptyset)$. The set of transition rules $E$ is defined by the following rules.
\begin{itemize}
  \item The transitions within the \emph{left} mode are the same as the
   parsing automata in \cite{CCH+18}, augmented with the assignment function $s$ such that $s(x_{res}) = res \concat a$ and $s(x_{e'})=x_{e'}$ for
  every $e' \in C_{e_1}$, where $a$ is the input character.
  
  \item Suppose $(\rho \{ q_0 \}, \tmop{left}, S) \in Q'$ and $a \in \Sigma$.
  If $\delta (S, a) \cap F = \emptyset$, $\delta^{\ast} (\rho, a) \cap F =
  \emptyset$ and $\delta (q_0, a) \nsubseteq \delta (S, a) \cup \delta^{\ast}
  (\rho, a)$, then for every $q' \in \delta (q_0, a) \setminus (\delta (S, a) \cup \delta^{\ast}(\rho, a))$, we have
  \[ ((\rho \{ q_0 \}, \tmop{left}, S), a, (\{ q' \}, \tmop{long}, \delta (S,
     a) \cup \delta^{\ast} (\rho, a)), s) \in E \]
  where $s$ is the assignment function defined as follows: $s(x_{e'}) = a$ for every $e'  \in C(q')$, and $s(y)=y$ for every other string variable $y \in X$.
  
  \item Suppose $(\{ q \}, \tmop{long}, S) \in Q'$, and $a \in \Sigma$. If
  $\delta (S, a) \cap F = \emptyset$, and \ $\delta (q, a) \nsubseteq \delta
  (S, a)$, then for every $q' \in \delta (q, a) \setminus \delta(S, a)$, we have
  \[ ((\{ q \}, \tmop{long}, S), a, (\{ q' \}, \tmop{long}, \delta (S, a)), s)
     \in E \]
  where $s$ is defined as follows:
  
  Suppose $\Theta = \{e' \mid e' = e''^*  \wedge
  q \in \esym(e'') \wedge q' \in \ssym(e'') \}$ and $C_{\Theta}$ denotes the set of $x_{e''}$ such that $e'' \in C_{e'}$ for some $e' \in \Theta$.
Then 
\begin{itemize}
\item for each $y \in C_{\Theta} \cap C(q')$, $s(y) =  a$,
%
\item for each $y \in C_{\Theta} \setminus C(q')$, $s(y) = \varepsilon$, 
%
\item for each $y \in C(q') \setminus C_\Theta$, $s(y) = y \concat a$,
%
\item for each $y \in X \setminus (C_\Theta \cup C(q'))$, $s(y)= y$.
\end{itemize}
  
  \item Suppose $(\{ q \}, \tmop{long}, S) \in Q'$, and $a \in \Sigma$. If
  $\delta (S, a) \cap F = \emptyset$ and $\delta (q, a) \cap F \neq
  \emptyset$, then for every state $q' \in \delta (q, a) \cap F$, we have
  \[ ((\{ q \}, \tmop{long}, S), a, (\{ q_0 \}, \tmop{left}, \delta (S, a)
     \cup q'), s) \in E \]
  where $s$ is defined as follows: $s (x_{res}) = x_{res}  \concat b_1   \ldots  b_n$ such that $e_2 = a_1 \ldots a_n$, and for each $i \in [n]$, if $a_i  \in \Sigma$, then $b_i = a_i$, otherwise, $a_i = \$ j$ for some $j$, let $e' \in C_{e_1}$ be the subexpression corresponding to the $j$-th capturing group of $e_1$, then $b_i = x_{e'}$. Moreover, $s(y) = \varepsilon$ for every other variable
  $y \in X$.
\end{itemize}
The output function $F'$ is simple: $F' (q) = x_{res}$  iff $q = (-, \tmop{left}, -) $.
\end{proof}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
xxx
\end{acks}

\section{Implementation}

\section{Experiments}


%% Bibliography
\bibliography{string}

%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots


\end{document}
