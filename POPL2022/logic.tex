%!TEX root = main.tex

\section{The String Constraint Language}\label{sec:logic}

We define the string constraint language $\strline$ below.
\[
\begin{array}{l c l}
\smallskip
S & \eqdef  & z:= x \concat y \mid y := \extract_{i, e}(x) \mid
y := \replace_{\pat, \rep}(x) \mid \\
& & y := \replaceall_{\pat, \rep}(x)   \mid
 \ASSERT{x \in e} \mid S; S\
\label{eq:SL}
\end{array}
\]
where
\begin{itemize}
	\item $\concat$ is the string concatenation operation which concatenates two strings,
%
\item for the $\extract$ function, $i \in \Nat$, $e \in \cgexp$,
%
	\item  for the $\replace$ and $\replaceall$ operation, $\pat\in \regexp$, $\rep \in \refexp$ (where $\refexp$ is defined below),
%
	\item for assertions, $e \in \regexp$.
\end{itemize}

The $\extract$ function is used to model the regular-expression match function in programming languages.
Specifically, the $\extract_{i, e}(x)$ function extracts the match of the $i$-th capturing group in the accepting match of $e$ to $x$ for $x \in \Lang(e)$ (otherwise, the return value of the function is undefined). Note that $\extract_{i, e}(x)$ returns $x$ if $i=0$. For instance, assuming $e = [[([\Gamma^+])\concat .?] \concat ([\Gamma^*])]$,   $\extract_{1, e}(0250)=0250$ and $\extract_{2, e}(0250)=\varepsilon$, as shown in Example~\ref{exmp-regex-semantics}. Moreover, if the $i$-the capturing group of $e$ is \emph{not} matched, even if $x \in \Lang(e)$, then $\extract_{i, e}(x)$ returns $\nullchar$. For instance, when $[[a^+] + ([a^*])]$ is matched against the string $aa$, $[a^+]$, instead of $([a^*])$, will be matched, since $[a^+]$ precedes $([a^*])$. Therefore, $\extract_{1, [[a^+] + ([a^*])]}(aa) = \nullchar$.


\begin{remark}
The match function in programming languages, e.g. $\sf str.match(reg)$ function in JavaScript, finds the first match of $\sf reg$ in $\sf str$. We can use $\extract$ to express the first match of $\sf reg$ in $\sf str$ by adding $[\Sigma^{*?}]$ and $[\Sigma^*]$ before and after $\sf reg$ respectively. More generally, the value of the $i$-th capturing group in the first match of a $\regexp$ $\sf reg$ in $\sf str$ can be specified as $\extract_{i+1, {\sf reg'}}({\sf str})$, where ${\sf reg'} = [[[\Sigma^{*?}] \concat ({\sf reg})] \concat [\Sigma^*]]$. The other string functions involving RWREs, e.g. {\sf exec} and {\sf test}, are similar to {\sf match}, thus can be encoded by $\extract$ as well.
\end{remark}

The function $\replaceall_{\pat, \rep}(x)$ is parameterized by the \emph{pattern} $\pat \in \regexp$ and the \emph{replacement string} $\rep \in \refexp$.
For an input string $x$, it identifies all matches of $\pat$ in $x$ and replaces them with strings specified by $\rep$.
The set $\refexp$ of replacement strings is defined using the following syntax, where $i \in \Nat$.
\[
    \rep = a \mid \$i \mid \refbefore \mid \refafter
\]
That is $\rep$ is a string of characters that may also contain \emph{references}.
A reference $\$i$ where $i > 0$ is instantiated by the string matched by the $i$th capture group.
For instance, let $w = 2.5, 3.4$, $\pat = [[([\Gamma^+])\concat .?] \concat ([\Gamma^*])]$ and $\rep = \$1$, then $\replaceall_{\pat, \rep}(w) = 2, 3$.

There are three special references\footnote{
    The corresponding syntax for $\refbefore$ and $\refafter$ in JavaScript is $\$`$ and $\$'$.
} $\$0$, $\refbefore$, and $\refafter$.
These are instantiated by the matched text, the text occurring before the match, and the text occurring after the match respectively.
In particular, if the input word is $u v w$ where $v$ has been matched and will be replaced, then $\$0$ takes the value $v$, $\refbefore$ takes the value $u$, and $\refafter$ takes the value $w$.
When there are multiple matches in a $\replaceall$, the values of $\refbefore$ and $\refafter$ are always with respect to the original input string.

The $\replace_{\pat, \rep}(x)$ function is similar to $\replaceall_{\pat, \rep}(x)$, except that it replaces only the first (leftmost) match of $\pat$.

Without loss of generality, we assume that all the $\strline$ programs are in single static assignment (SSA) form, that is 1) each variable $x$ is assigned at most once; and 2) if $x$ is assigned, all its occurrences on the right hand sides of the assignment statements or in assertions are after the assignment statement of $x$.
%
For an $\strline$ program $S$, a variable $x$ occurring in $S$ is said to be an \emph{input} variable if $x$ does not occur on the left hand sides of assignment statements.

The \emph{path feasibility} problem of an $\strline$ program is to decide whether there are valuations of the input variables so that the program can execute to the end.
This problem turns out to be undecidable, this is because of the backreferences in assertion statements or in pattern parameters of the $\replace$/$\replaceall$ function.

\begin{proposition}\label{prop-und}
The path feasibility problem of $\strline$ is undecidable.
\end{proposition}


We shall show that the path feasibility problem becomes decidable, if the uses of backreferences in assertion statements and pattern parameters of the $\replace$/$\replaceall$ function are forbidden, which turns out to be the situation in practice,  according to the statistics in the literature (see Section~\ref{sec-intro}).
In the sequel, we will use $\strline_{\sf reg}$ to denote the collection of $\strline$ programs which are free of
backreferences in assertion statements as well as in pattern parameters of the $\replace$/$\replaceall$ function.
Note that $\strline_{\sf reg}$  allows backreferences in replacement parameters of $\replace$/$\replaceall$. The main result of this paper is as follows.


\begin{theorem}\label{thm-main}
The path feasibility of $\strline_{\sf reg}$ is decidable.
\end{theorem}
The decision procedure for $\strline_{\sf reg}$ utilizes a new automata model called prioritized streaming string transducers, which will be defined in the next section.
