%!TEX root = main.tex

\section{A Propagation-Based Calculus for String Constraints}
\label{sect:calculus}

\philipp{problem: the calculus also uses complemented regular
  expressions; should we add those to the considered regex language?}

We now introduce our calculus for solving string constraints in
$\strline$, state its correctness, and observe that it gives rise to
decision procedures for several fragments, including for
$\strline_{\sf reg}$ formulas that are straightline and do not contain
back-references. The calculus is based on the principle of propagating
regular language constraints by computing images and post-images of
string functions. The calculus is parameterized in the set of string
functions; in this paper, we work with the set
$\{\concat, \extract_{i, e}, \replace_{\pat, \rep}, \replaceall_{\pat,
  \rep}\}$ consisting of concatenation, extraction, and replacement,
but also other functions that can be represented as PSSTs can be
included.

%The calculus 

\begin{table}
  \begin{gather*}
    \infer
    {\seqq{\varphi \wedge \psi}}
    {\seqq{\varphi, \psi}}
    \qquad
    \infer
    {\seqq{ \neg(\varphi \vee \psi)}}
    {\seqq{ \neg\varphi, \neg\psi}}
    \qquad
    \inferii
    {\seqq{\varphi \vee \psi}}
    {\seqq{\varphi}}{\seqq{\psi}}
    \qquad
    \inferii
    {\seqq{\neg(\varphi \wedge \psi)}}
    {\seqq{\neg\varphi}}{\seqq{\neg\psi}}
    \qquad
    \infer
    {\seqq{ \neg\neg\varphi}}
    {\seqq{\varphi}}
    \\[1ex]
    \infer
    {\seqq{x \not\in e}}
    {\seqq{x \in e^c}}
    \qquad
    \inferC{\text{where~} y \text{~is fresh}}
    {\seqq{x \not= f(x_1, \ldots, x_n)}}
    {\seqq{x \not= y, y = f(x_1, \ldots, x_n)}}
    \qquad
    \inferii[Cut]
    {\seqq{}}
    {\seqq{x \in e}}{\seqq{x \in e^c}}
    \\[2ex]
    \begin{array}{cl}
      \infer[Close]
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      {}
      &
        \text{if~} \lang{e_1} \cap \cdots \cap\lang{e_n} = \emptyset
      \\[2ex]
      \infer[Subsume]
      {\seqq{x \in e, x \in e_1, \ldots, x \in e_n}}
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      &
        \text{if~} \lang{e_1} \cap \cdots \cap\lang{e_n} \subseteq \lang{e}
      \\[2.5ex]
      \infer[Intersect]
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      {\seqq{x \in e}}
      &
        \text{if~}
        \begin{array}{l}
          n > 1 \text{~and~}
          \\
          \lang{e_1} \cap \cdots \cap\lang{e_n} = \lang{e}
        \end{array}
      \\[4ex]
      \infer[$=$-Prop]
      {\seqq{x \in e, x = y}}
      {\seqq{x \in e, x = y, y \in e}}
      \\[3ex]
      \infer[$\not=$-Prop-Elim]
      {\seqq{x \in e, x \not= y}}
      {\seqq{x \in e, y \in e^c}}
      &
        \text{if~} |\lang{e}| = 1
      \\[3ex]
      \infer[$\not=$-Subsume]
      {\seqq{x \in e_1, x \not= y, y \in e_2}}
      {\seqq{x \in e_1, y \in e_2}}
      &
        \text{if~} \lang{e_1} \cap \lang{e_2} = \emptyset
      \\[4ex]
      \infer[Fwd-Prop]
      {\seqq{x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      {\seqq{x \in e, x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      &
        \text{if~} \lang{e} = f(\lang{e_1}, \ldots, \lang{e_n})
      \\[3ex]
      \infer[Fwd-Prop-Elim]
      {\seqq{x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      {\seqq{x \in e, x_1 \in e_1, \ldots, x_n \in e_n}}
      &
        \text{if~}
        \begin{array}{l}
          \lang{e} = f(\lang{e_1}, \ldots, \lang{e_n})
          \\
          \text{and~} 
          |\lang{e}|= 1
          \end{array}
      \\[3ex]
      \infer[Bwd-Prop]
      {\seqq{x \in e, x = f(x_1, \ldots, x_n)}}
      {\big\{\seqq{x \in e, x = f(x_1, \ldots, x_n),
      x_1 \in e_1^i, \ldots, x_n \in e_n^i}\big\}_{i=1}^k}
      &
        \text{if~}
        \begin{array}{l}
          f^{-1}(\lang{e}) = \\
          \bigcup_{i=1}^k \big( \lang{e_1^i} \times \cdots \times \lang{e_n^i} \big)
          \end{array}
    \end{array}
  \end{gather*}
  
  \caption{Rules of the one-sided sequent calculus}
\end{table}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
