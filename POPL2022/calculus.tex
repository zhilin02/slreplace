%!TEX root = main.tex

\section{A Propagation-Based Calculus for String Constraints}
\label{sect:calculus}

\begin{table}
  \caption{Rules of the one-sided sequent calculus. A term
    $e^c$ denotes the complement of a regular expression~$e$,  i.e.,
    ~$\lang{e^c} = \Sigma^* \setminus \lang{e}$.}
  \label{tab:calculus}
  
  \begin{gather*}
    \infer[$\wedge$]
    {\seqq{\varphi \wedge \psi}}
    {\seqq{\varphi, \psi}}
    \quad
    \infer[$\neg\wedge$]
    {\seqq{ \neg(\varphi \vee \psi)}}
    {\seqq{ \neg\varphi, \neg\psi}}
    \quad
    \inferii[$\vee$]
    {\seqq{\varphi \vee \psi}}
    {\seqq{\varphi}}{\seqq{\psi}}
    \quad
    \inferii[$\neg\vee$]
    {\seqq{\neg(\varphi \wedge \psi)}}
    {\seqq{\neg\varphi}}{\seqq{\neg\psi}}
    \quad
    \infer[$\neg\neg$]
    {\seqq{ \neg\neg\varphi}}
    {\seqq{\varphi}}
    \\[1ex]
    \infer[$\not\in$]
    {\seqq{x \not\in e}}
    {\seqq{x \in e^c}}
    \quad
    \inferC[\ruleName{$\not=$}]{\text{where~} y \text{~is fresh}}
    {\seqq{x \not= f(x_1, \ldots, x_n)}}
    {\seqq{x \not= y, y = f(x_1, \ldots, x_n)}}
    \quad
    \inferii[Cut]
    {\seqq{}}
    {\seqq{x \in e}}{\seqq{x \in e^c}}
    \\[2ex]
    \begin{array}{cl}
      \infer[Close]
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      {}
      &
        \text{if~} \lang{e_1} \cap \cdots \cap\lang{e_n} = \emptyset
      \\[2ex]
      \infer[Subsume]
      {\seqq{x \in e, x \in e_1, \ldots, x \in e_n}}
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      &
        \text{if~} \lang{e_1} \cap \cdots \cap\lang{e_n} \subseteq \lang{e}
      \\[2.5ex]
      \infer[Intersect]
      {\seqq{x \in e_1, \ldots, x \in e_n}}
      {\seqq{x \in e}}
      &
        \text{if~}
        \begin{array}{l}
          n > 1 \text{~and~}
          \\
          \lang{e_1} \cap \cdots \cap\lang{e_n} = \lang{e}
        \end{array}
      \\[4ex]
      \infer[$=$-Prop]
      {\seqq{x \in e, x = y}}
      {\seqq{x \in e, x = y, y \in e}}
      \\[3ex]
      \infer[$=$-Prop-Elim]
      {\seqq{x \in e, x = y}}
      {\seqq{x \in e, y \in e}}
      &
        \text{if~} |\lang{e}| = 1
      \\[3ex]
      \infer[$\not=$-Prop-Elim]
      {\seqq{x \in e, x \not= y}}
      {\seqq{x \in e, y \in e^c}}
      &
        \text{if~} |\lang{e}| = 1
      \\[3ex]
      \infer[$\not=$-Subsume]
      {\seqq{x \in e_1, x \not= y, y \in e_2}}
      {\seqq{x \in e_1, y \in e_2}}
      &
        \text{if~} \lang{e_1} \cap \lang{e_2} = \emptyset
      \\[4ex]
      \infer[Fwd-Prop]
      {\seqq{x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      {\seqq{x \in e, x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      &
        \text{if~} \lang{e} = f(\lang{e_1}, \ldots, \lang{e_n})
      \\[3ex]
      \infer[Fwd-Prop-Elim]
      {\seqq{x = f(x_1, \ldots, x_n), x_1 \in e_1, \ldots, x_n \in e_n}}
      {\seqq{x \in e, x_1 \in e_1, \ldots, x_n \in e_n}}
      &
        \text{if~}
        \begin{array}{l}
          \lang{e} = f(\lang{e_1}, \ldots, \lang{e_n})
          \\
          \text{and~} 
          |\lang{e}|= 1
          \end{array}
      \\[3ex]
      \infer[Bwd-Prop]
      {\seqq{x \in e, x = f(x_1, \ldots, x_n)}}
      {\big\{\seqq{x \in e, x = f(x_1, \ldots, x_n),
      x_1 \in e_1^i, \ldots, x_n \in e_n^i}\big\}_{i=1}^k}
      &
        \text{if~}
        \begin{array}{l}
          f^{-1}(\lang{e}) = \\
          \bigcup_{i=1}^k \big( \lang{e_1^i} \times \cdots \times \lang{e_n^i} \big)
          \end{array}
    \end{array}
  \end{gather*}
\end{table}

We now introduce our calculus for solving string constraints in
$\strline$, state its correctness, and observe that it gives rise to a
decision procedure for the fragment $\strlinesl$ of formulas that are
straightline and do not contain back-references. The calculus is based
on the principle of propagating regular language constraints by
computing images and post-images of string functions. We deliberately
keep the calculus minimalist and focus on the main proof rules; for an
implementation, the calculus has to be complemented with a suitable
strategy for applying the rules, as well as standard SMT optimizations
such as non-chronological back-tracking and conflict-driven learning.
%
Our calculus is parameterized in the set of considered string
functions; in this paper, we work with the set
$\{\concat, \extract, \replace, \replaceall\}$ consisting of
concatenation, extraction, and replacement, but this set can be
extended by other functions for which images and/or pre-images can be
computed (see Section~\ref{sec:rules}).

\subsection{Sequents}

The calculus operates on \emph{one-sided sequents,} and can be
interpreted as a sequent calculus in the sense of
Gentzen~\cite{Gentzen35} in which all formulas are located in the
antecedent (to the left of the turnstile~$\vdash$). A one-sided sequent is a
finite set $\Gamma \subseteq \strline$ of string constraints. For sake
of presentation, we write sequents as lists of formulas separated by
comma, and $\seqq{\varphi_1, \ldots, \varphi_n}$ for the union
$\Gamma \cup \{\varphi_1, \ldots, \varphi_n\}$. We say that a
sequent~$\seqq{}$ is \emph{unsatisfiable} if $\bigwedge \Gamma$ is
unsatisfiable. Our calculus is refutational and has the purpose of
either showing that some initial sequent~$\seqq{}$ is unsatisfiable,
or that it is satisfiable by constructing a solution for it. A
solution is a
sequent~$\seq{x_1 \in w_1, x_2 \in w_2, \ldots, x_n \in w_n}$ that
defines the values of string variables using regexes that only consist
of single words.

\begin{figure}
  \begin{prooftree}
    \AxiomC{}
    \LeftLabel{\ruleName{Close}}
    \UnaryInfC{$x \in a^+\Sigma^*,
      x = y \concat z, y \in a^+, z \in \Sigma^*,
      x \in (a^c)^+, x = \replaceall_{a,
        b}(x)$}
    \LeftLabel{\ruleName{Fwd-Prop}}
    \UnaryInfC{$x \in a^+\Sigma^*,
      x = y \concat z, y \in a^+, z \in \Sigma^*, x = \replaceall_{a,
        b}(x)$}
    \LeftLabel{\ruleName{Fwd-Prop}}
    \UnaryInfC{$x = y \concat z, y \in a^+, z \in \Sigma^*, x = \replaceall_{a,
        b}(x)$}
    \LeftLabel{\ruleName{$\wedge^*$}}
    \UnaryInfC{$x = y \concat z \wedge y \in a^+ \wedge z \in \Sigma^*
      \wedge x = \replaceall_{a,
    b}(x)$}
  \end{prooftree}

  \caption{Proof of unsatisfiability for \eqref{eq:calcEx1} in
    Example~\ref{ex:calc1}}
  \label{fig:calcEx1}
\end{figure}

\begin{figure}
  \begin{prooftree}
    \AxiomC{$x \in a, z \in a, y \in \epsilon, r \in b$}
    \LeftLabel{\ruleName{Subsume$\mbox{}^*$}}
    \UnaryInfC{$x \in a, z \in a, y \in \epsilon, r \in b, \ldots$}
    \LeftLabel{\ruleName{Fwd-Prop-Elim}}
    \UnaryInfC{$z \in a, y \in \epsilon, x \in a, r = \replaceall_{a, b}(x), \ldots$}
    \LeftLabel{\ruleName{Fwd-Prop-Elim}}
    \UnaryInfC{$z \in a, y \in \epsilon, x = y \cdot z, \ldots$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$z \in a^c, \ldots$}
    \LeftLabel{\ruleName{Cut}}
    \BinaryInfC{$y \in \epsilon, z \in a^+, x = y \concat z, 
      x \in a^+, \ldots$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$y \in a^+, z \in a^*, \ldots$}
    \LeftLabel{\ruleName{Bwd-Prop}}
    \BinaryInfC{$x = y \concat z, x \in a^+, r = \replaceall_{a, b}(x)$}
    \LeftLabel{\ruleName{$\wedge^*$}}
    \UnaryInfC{$x = y \concat z \wedge x \in a^+ \wedge r = \replaceall_{a, b}(x)$}
  \end{prooftree}

  \caption{Proof of satisfiability for \eqref{eq:calcEx2} in
    Example~\ref{ex:calc1}}
  \label{fig:calcEx2}
\end{figure}

\begin{example}
  \label{ex:calc1}
  We first illustrate the calculus by showing unsatisfiability of the
  constraint:
  \begin{equation}
    \label{eq:calcEx1}
    x = y \concat z \wedge y \in a^+ \wedge z \in \Sigma^*
    \wedge x = \replaceall_{a, b}(x)
  \end{equation}
  To this end, we construct a proof tree that has \eqref{eq:calcEx1}
  as its root, by applying proof rules until all proof goals have been
  closed (Figure~\ref{fig:calcEx1}). The proof is growing upward, and
  is built by first eliminating the conjunctions~$\wedge$, resulting
  in a list of formulas. Next, we apply the rule~\ruleName{Fwd-Prop} for
  \emph{forward-propagation} of a regular expression constraint. Given
  that $y \in a^+, z \in \Sigma^*$, from the
  equation~$x = y \concat z$ we can conclude that $x \in
  a^+\Sigma^*$. From $x \in a^+\Sigma^*$ and
  $x = \replaceall_{a, b}(x)$, we can next conclude that
  $x \in (a^c)^+$, i.e., $x$ cannot contain the letter~$a$. Finally,
  the proof can be closed because the languages~$a^+\Sigma^*$ and
  $(a^c)^+$ are disjoint.

  We next consider the case of a satisfiable formula in $\strlinesl$:
  \begin{equation}
    \label{eq:calcEx2}
    x = y \concat z \wedge x \in a^+ \wedge r = \replaceall_{a, b}(x)
  \end{equation}
  [to be continued]
\end{example}

\subsection{Proofs and Proof Rules}
\label{sec:rules}

More formally, proof rules are relations between a finite list of
sequents (the premises), and a single sequent (the conclusion). Proofs
are finite trees growing upward, in which each node is labeled with a
sequent, and each non-leaf node is related to the node(s) directly
above it through an instance of a proof rule. A proof branch is a path
from the proof root to a leaf. A branch is closed if a closure rule (a
rule without premises) has been applied to its leaf, and open
otherwise. A proof is closed if all of its branches are closed.

The proof rules of the calculus are shown in
Table~\ref{tab:calculus}. The first row shows standard proof rules to
handle Boolean operators; see, e.g.,
\cite{DBLP:books/daglib/0022394}. Rule~\ruleName{$\not\in$} turns
negated membership predicates into positive ones through
complementation, and rule~\ruleName{$\not=$} negative function
applications into positive ones. As a result, only disequalities
between string variables remain. The rule~\ruleName{Cut} can be use to
introduce case splits, and is mainly needed to extract solutions once
propagation has converged (as shown in Example~\ref{ex:calc1}).

The rule~\ruleName{Close} closes proof branches that contain
contradictory regex constraints, and is the only closure rule needed
in our calculus. \ruleName{Subsume} removes regex constraints
that are implied by other constraints in a sequent, and
\ruleName{Intersect} replaces multiple regexes with a single
constraint.

The next four rules handle equations between string
variables. Rule~\ruleName{=-Prop} propagates regex constraints from
the left-hand side to the right-hand side of an equation;
\ruleName{=-Prop-Elim} in addition removes the equation in the case
where the propagated constraint has a unique solution. The
rule~\ruleName{$\not$=-Prop-Elim} similarly turns a singleton regex
for the left-hand side of a disequality into a regex constraint on the
right-hand side.  As a convention, we allow application of
\ruleName{=-Prop}, \ruleName{=-Prop-Elim}, and
\ruleName{$\not$=-Prop-Elim} in both directions, left-to-right and
right-to-left. Finally, \ruleName{$\not=$-Subsume} eliminates
disequalities that are implied by the regex constraints of a proof
goal.

The last three rules handle applications of functions
$f \in \{\concat, \extract, \replace, \replaceall\}$ through
propagation. Rule~\ruleName{Fwd-Prop} defines forward propagation, and
adds a regex constraint~$x \in e$ for the value of a function by
propagating constraints about the arguments. The regex~$e$ encodes
the image of the argument regexes under $f$:
%
\begin{definition}[Image]
  For an $n$-ary string
  function~$f : \Sigma^* \times \cdots \times \Sigma^* \to \Sigma^*$
  and languages $L_1, \ldots, L_n \subseteq \Sigma^*$, we define the
  \emph{image} of $L_1, \ldots, L_n$ under $f$ as
  $f(L_1, \ldots, L_n) = \{f(w_1, \ldots, w_n) \in \Sigma^* \mid w_1
  \in L_1, \ldots, w_n \in L_n \}$.
\end{definition}

Forward propagation is often useful to prune proof branches. It is
easy to see, however, that the images of regular languages under the
functions considered in this paper are not always regular; for
instance, $\replace_{\pat,\$0\$0}$ can map regular languages to
context-sensitive languages. In such cases, the side condition of
\ruleName{Fwd-Prop} cannot be satisfied by any regex~$e$, and the rule
is not applicable.

Rule~\ruleName{Fwd-Prop-Elim} handles the special case of forward
propagation producing a singleton language. In this case, the function
application is not needed for further reasoning and can be
eliminated. This rule is mainly used during the extraction of
solutions (as shown in Example~\ref{ex:calc1}).

Rule~\ruleName{Bwd-Prop} defines the dual case of backward
propagation, and derives regex constraints for function arguments
from a constraint about the function value. The argument constraints
encode the \emph{pre-image} of the propagated language:
%
\begin{definition}[Pre-image]
  For an $n$-ary string
  function~$f : \Sigma^* \times \cdots \times \Sigma^* \to \Sigma^*$
  and a language $L \subseteq \Sigma^*$, we define the
  \emph{pre-image} of $L$ under $f$ as the relation
  $f^{-1}(L) = \{(w_1, \ldots, w_n) \in (\Sigma^*)^n \mid 
  f(w_1, \ldots, w_n) \in L\}$.
\end{definition}
A \textbf{key result} of the paper is that pre-images of regular
languages under the functions considered in the paper can always be
represented in the
form~$\bigcup_{i=1}^k ( \lang{e_1^i} \times \cdots \times \lang{e_n^i}
)$, i.e., they are \emph{recognizable languages}~\cite{X}. This implies that
\ruleName{Bwd-Prop} is applicable whenever a regex constraint for the
result of a function application exists, and prepares the ground for
the decidability result in the next section.  For concatenation,
recognizability was shown in \cite{Abdulla14,CHL+19}. This paper
contributes the corresponding result for all functions defined by
PSSTs:
%
\begin{lemma}[Pre-image of regular languages under PSSTs]
  \label{lem:psst_preimage}
  Given a PSST $\psst = (Q_T, \Sigma$, $X$, $\delta_T$, $\tau_T$, $E_T$,  $q_{0, T}$, $F_T$) and an \FA{} $\Aut
  = (Q_A, \Sigma, \delta_A, q_{0, A}, F_A)$, we can compute an \FA{} $\cB = (Q_B,
  \Sigma, \delta_B, q_{0, B}, F_B)$ in exponential time  such that $\Lang(\cB) = \cR^{-1}_{\cT}(\Lang(\Aut))$.
\end{lemma}
The proof of Lemma~\ref{lem:psst_preimage} is given in
Appendix~\ref{app-pre-image}, and the reduction of
$\extract, \replace, \replaceall$ to PSSTs in
Appendix~\ref{appendix:sec-extract-replace-to-psst}. 
We note that, when the replacement strings do not contain $\refbefore$ or $\refafter$, the PSSTs in the reduction satisfy the \emph{copyless} property~\cite{AC10}, whereas ``copyful'' PSSTs are needed for $\refbefore$ and $\refafter$.

\medskip
%
We can finally observe that the calculus is sound:
\begin{lemma}[Soundness]
  The sequent calculus defined by Table~\ref{tab:calculus} is sound:
  (i) the root of a closed proof is an unsatisfiable sequent; and (ii)
  if a proof has an open branch that ends with a
  solution~$\seq{x_1 \in w_1, x_2 \in w_2, \ldots, x_n \in w_n}$, then
  the
  assignment~$\{x_1 \mapsto w_1, x_2 \mapsto w_2, \ldots, x_n \mapsto
  w_n\}$ is a satisfying assignment of the root sequent.
\end{lemma}

\begin{proof}
  By showing that each of the proof rules in Table~\ref{tab:calculus}
  is an equivalence transformation: the conclusion of a proof rule is
  equivalent to the disjunction of the premises.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
