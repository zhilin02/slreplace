\section{Semantics}

Our goal in this section is to define the formal semantics of {\regexp}-string matching. 
Traditionally, a regular expression in formal language theory is interpreted as a regular language, i.e., a set of strings, which can be defined inductively in a rather straightforward way. In the context of string constraint solving, as regular expressions are used as arguments in string functions (e.g., {\sf match} and {\sf replace} in JavaScript), %owing to the introduction of greedy/lazy semantics,  
what we need is not only the language denoted by the regular expression, but also the intermediate results when parsing a string against the given regular expression. This is especially the case when the capturing group is involved. As a result, we need a more operational (as opposed traditionally denotational) account of the semantics for regular expressions. To this end, we harness an extension of finite-state automata with transition priorities and string variables, called prioritized streaming string transducers (abbreviated as \PSST), to define how a string is parsed by the given regular expression. 
%We start with the standard finite-state automaton.  

In {\PSST}s, transition priorities are used to capture the non-standard semantics of {\regexp} operators whereas string variables are used to store the matchings of capturing groups. {\PSST}s combine two automata models introduced before, namely, prioritized finite-state automata \cite{BM17} and streaming string transducers \cite{AC10,AD11}. The formal semantics of {\regexp}-string matching is defined by constructing {\PSST}s out of regular expressions. 
%
As we shall validate the formal semantics against the actual one of {\regexp}-string matching in programming languages and there are subtle differences between the implementations of {\regexp} in different languages (e.g. JavaScript and Python), it is necessary to choose one specific language to exercise the validation. We choose JavaScript here, since it is one of the most widely used programming languages,  currently the top-one active language in Github.\footnote{https://githut.info/}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\OMIT{
%It should be pointed out that if only the set of strings defined by regular expressions are concerned, regular expressions in Javascript (with backreferences ignored) are the same as classical regular expressions in formal language textbooks (e.g. \cite{HU79}). Nevertheless, matching of regular expressions to strings in Javascript, e.g. in the string functions ``exec()'', ``match()'' and ``test()'' , are much more involved: 
%\begin{enumerate}
%\item in Javascript, the regular expressions are not required to be matched to the whole string, but to a substring, which intuitively corresponds to the first match of the regular expression in the string, moreover, this matching is \emph{deterministic} in the sense that for a given regular expression and a string, the matching returns a \emph{unique} substring (if there is any), 
%%
%\item regular expressions in Javascript typically contain capturing groups, and the matchings of these capturing groups in strings should also be returned, moreover, these matchings are also deterministic.
%\end{enumerate}
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We shall start with the syntax of regular expressions, which are essentially those used in JavaScript. (We do not include backreferences though.) We then formalize the semantics of JavaScript \regexp-string matching in Section~\ref{sect:regextopsst}; the experimental validation is presented in 
%Furthermore, we also carry out  extensive experiments to validate the formal semantics against the actual semantics of regex-string matching in JavaScript (cf.\ 
Section~\ref{sect：valid}).
%
%The key %of the formal semantics 
%here is a new automata model prioritized streaming string transducers (PSSTs), where transition priorities are used to capture the non-standard semantics of regular-expression operators, and string variables are used to store the matchings of capturing groups. PSST combines two automata models introduced before, namely, prioritized finite-state automata \cite{BM17} and streaming string transducers \cite{AC10,AD11}. 

%The formal semantics of Javascript regex-string matching is defined by constructing a PSST out of regular expressions. 



%We now define the formal semantics of {\regexp}. 
%Note that traditionally regular expressions are interpreted as a regular language, i.e., a set of strings, which can be defined inductively in a rather straightforward way. 
%In our case when the regular expression is used in string constraints arisen from analysis of programming language such as JavaScript, %owing to the introduction of greedy/lazy semantics,  
%what we need is not only the language denoted by the regular expression, but also the intermediate result when parsing a string against the given regular expression. This is especially the case when the capturing group is involved. As a result, 
%
%Here we present a more operational (as opposed traditional denotational) account of the semantics by constructing  PSSTs out of regular expressions (cf.\ Section~\ref{sect:regextopsst}). 
%
%. To this end, we harness an extension of finite-state automata with priorities, which \emph{defines} how a string is accepted by the given regular expression. We start with the standard finite-state automaton. 
%


%
%=======
%
%In the sequel, we first define the syntax of {\regexp}. 
%%
%Then we define PSSTs and construct PSSTs out of {\regexp}s to define the semantics of regex-string matching. Finally, we validate the formal semantics against the actual Javascript semantics.
%
%%
%%Furthermore, we also do extensive experiments to validate the formal semantics against the actual semantics of regex-string matching in Javascript.
%>>>>>>> 658ffd954615e7a463bc6ba5b933083613849a72

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\OMIT{
	In this section, we introduce the regular expressions which will be used in the string constraints. 
	%The semantics of the regular language conforms to the JavaScript language. 
	It should be emphasized that the strings accepted by the regular expresses introduced here are still regular, but the parsing of the string is significantly different from classic regular languages. For this purpose, we utilize prioritized finite-state automata \cite{BM17}, which extend classic finite-state automata with priorities, to capture, among others, the greedy/lazy semantics of Kleene star/plus in the regular expression. 
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\medskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Prioritized streaming string transducers (\PSST)}

\input{psst-epsilon.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Defining the Semantics of \regexp-String Matching by PSSTs} \label{sect:regextopsst}


\input{regextopsst.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validation experiments for the formal semantics} \label{sect：valid}

\input{sem-exp.tex}