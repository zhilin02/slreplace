%!TEX root = main.tex

\section{Implementation and Experiments}
\label{sect:impl}

We have implemented our decision procedure for $\strline_{\sf reg}$ in the SMT
solver \ostrich.\footnote{Name anonymized for doubly-blind review,
and will be provided in the final version.}
%\cite{CHL+19}, %\url{https://github.com/uuverifiers/ostrich}}
%which provides a modular and easy-to-use framework for extending all
%sorts of string operations. 
As shown in Section \ref{sec:decision},
PSSTs satisfy the conditions required by the backward reasoning
approach of \ostrich, which enables us to integrate our logic with
standard string theory. The resulting extended theory of strings is a
conservative extension of the SMT-LIB theory of Unicode
strings.\footnote{\url{http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml}}

\subsection{Input format}

Our implementation extends classical regular expression in SMT-LIB
with indexed {\sf re.capture} and {\sf re.reference} operators, which
denote capturing groups and references to them. We also add {\sf re.*?}
and {\sf re.+?} for lazy Kleene stars.

The three string operators that use these extended real world regular
expressions are {\sf str.replace\_cg}, {\sf str.replace\_cg\_all}, and
{\sf str.extract}. Operators {\sf str.replace\_cg} and {\sf
  str.replace\_cg\_all} are counterparts of the standard {\sf
  str.replace\_re} and {\sf replace\_re\_all} operators, and allow
capturing groups in the match pattern and references in the
replacement pattern. As an example, the following constraint swaps
lower-case characters~$x$ with a sub-sequent upper-case character~$Y$:
%
\begin{minted}{lisp}
  (= w (str.replace_cg_all v
                   (re.++ ((_ re.capture 1) (re.range "a" "z"))
                          ((_ re.capture 2) (re.range "A" "Z")))
                   (re.++ (_ re.reference 2) (_ re.reference 1))))
\end{minted}
%
The replacement string is written as a regular expression only
containing the operators {\sf re.++}, {\sf str.to\_re}, and {\sf re.reference}. In contrast to the standard operators, it is not allowed to use string variables in the 
replacement parameter.

The indexed operator {\sf str.extract} implements $\extract_{i, e}$ in
$\strline$. For instance,
%
\begin{minted}{lisp}
  ((_ str.extract 1)
        (re.++ (re.*? re.allchar)
               ((_ re.capture 1) (re.+ (re.range "a" "z"))
               re.all)) x)
\end{minted}
%
extracts the left-most, longest sub-string consisting of only lower-case
characters from a string~$x$.

Our implementation is able to handle \textit{anchors} as well. Due to space restrictions we did not introduce them as part of our formalism. Basically, anchors are special symbols that match certain positions of a string without consuming any characters. In most practical programming languages, it is quite common to use \verb!^! and \verb!$! in regular expressions to signify the start and end of a string, respectively. We add \textsf{re.begin-anchor} and \textsf{re.end-anchor} for them.

\subsection{Implementation}

Our implementation revolves around PSSTs. Any of the three string operators mentioned above will be converted into an equivalent PSST (See Appendix~\ref{appendix:sec-extract-replace-to-psst}). {\ostrich} then iterates the dependency graph and repeatedly eliminates the them. More specifically, we first use Lemma \ref{lem:psst_preimage} to back-propagate regular constraints on string variables and check satisfiability, then use forward concrete evaluation to generate a model. 

\subsection{Experimental evaluation}

\begin{table}[tb]
  \begin{center}
  \begin{tabular}{l@{\quad}c@{\quad}|*{6}{c}|@{\quad}c}
     & &
    \multicolumn{6}{c|@{\quad}}{\textbf{\ostrich}} & \textbf{ExpoSE}
    \\
      && \multicolumn{6}{c|@{\quad}}{\# solved queries}
    \\
     & \#Benchm.& ~~0~~ & ~~1~~ & ~~2~~ & ~~3~~ & ~~4~~ & ~~\#Err~~
    \\\hline
    \textbf{Match} & 98117 & 75 & 88 & 176 & 79 & 96565 & 1132
    \\
    && \multicolumn{6}{c|@{\quad}}{Average time: 0.63s}
    \\
    && \multicolumn{6}{c|@{\quad}}{Total \#sat: 108132, \#unsat: 279135}
    \\\hline
    \textbf{Replace} & 98117 & 445 & 229 & 576 & 95735 & --- & 1132
    \\
    && \multicolumn{6}{c|@{\quad}}{Average time: 1.02s}
    \\
    && \multicolumn{6}{c|@{\quad}}{Total \#sat: 273927, \#unsat: 14659}
  \end{tabular}
  \end{center}
  \caption{Results of running \ostrich\ and ExpoSE on regular
    expressions.  Average time is wall-clock time. All experiments
    were done on an AMD Opteron 2220 SE machine, running 64-bit Linux
    and Java~1.8.  Runtime was limited to 1min wall clock time, and
    heap space to 2GB.}
  \label{tab:exp}
\end{table}

Our experiments have the purpose of answering two main questions:\\
\textbf{R1:} How does \ostrich\ compare to
other solvers
that can handle replace(All) and capturing groups? \zhilin{that can handle real-world regular expressions, e.g. greedy/lazy Kleene star and capturing groups ?}
\\
\textbf{R2:} How does it perform in the context of symbolic execution,
the prime application of string solving?
\\
\zhilin{\textbf{R3:} Are the semantics of RWREs defined in this paper consistent with that of ECMAScript(Javascript) regular expressions ?}

Concerning \textbf{R1}, we are not aware of other SMT solvers with
support for capturing groups; the same holds for CP solvers (e.g.,
\cite{DBLP:conf/cpaior/ScottFPS17,DBLP:conf/cp/AmadiniGS20}). The
closest related work is the algorithm implemented in the symbolic
execution tool ExpoSE~\cite{DBLP:conf/spin/LoringMK17,LMK19}, which
applies Z3-seq~\cite{Z3} for solving string constraints, but augments
it with a refinement loop to approximate the semantics of
replace(All).\footnote{We also considered to replace Z3 with \ostrich\
  in ExpoSE for the experiments. However, ExpoSE integrates Z3 using
  its C API, and changing to a solver like \ostrich, with native
  support for capture groups, would have required the rewrite of
  substantial parts of ExpoSE.}
%
For \textbf{R1}, we therefore compared \ostrich\ with ExpoSE on
regular expressions taken from the ??? library.
