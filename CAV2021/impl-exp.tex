%!TEX root = main.tex

\section{Implementation and Experiments}
\label{sect:impl}

We have implemented our decision procedure for $\strline_{\sf reg}$ in the SMT
solver \ostrich,\footnote{Name anonymized for doubly-blind review,
and will be provided in the final version.} extending the
open-source solver OSTRICH~\cite{CHL+19}.
%\cite{CHL+19}, %\url{https://github.com/uuverifiers/ostrich}}
%which provides a modular and easy-to-use framework for extending all
%sorts of string operations. 
As shown in Section \ref{sec:decision},
PSSTs satisfy the conditions required by the backward reasoning
approach of OSTRICH, which enables us to integrate our logic with
standard string theory. The resulting extended theory of strings is a
conservative extension of the SMT-LIB theory of Unicode
strings.\footnote{\url{http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml}}

\subsection{Input format}

Our implementation extends classical regular expression in SMT-LIB
with indexed {\sf re.capture} and {\sf re.reference} operators, which
denote capturing groups and references to them. We also add {\sf re.*?}
and {\sf re.+?} for lazy Kleene stars.

The three string operators that use these extended real world regular
expressions are {\sf str.replace\_cg}, {\sf str.replace\_cg\_all}, and
{\sf str.extract}. Operators {\sf str.replace\_cg} and {\sf
  str.replace\_cg\_all} are counterparts of the standard {\sf
  str.replace\_re} and {\sf replace\_re\_all} operators, and allow
capturing groups in the match pattern and references in the
replacement pattern. As an example, the following constraint swaps
lower-case characters~$x$ with a sub-sequent upper-case character~$Y$:
%
\begin{minted}{lisp}
  (= w (str.replace_cg_all v
                   (re.++ ((_ re.capture 1) (re.range "a" "z"))
                          ((_ re.capture 2) (re.range "A" "Z")))
                   (re.++ (_ re.reference 2) (_ re.reference 1))))
\end{minted}
%
The replacement string is written as a regular expression only
containing the operators {\sf re.++}, {\sf str.to\_re}, and {\sf re.reference}. In contrast to the standard operators, it is not allowed to use string variables in the 
replacement parameter.

The indexed operator {\sf str.extract} implements $\extract_{i, e}$ in
$\strline$. For instance,
%
\begin{minted}{lisp}
  ((_ str.extract 1)
        (re.++ (re.*? re.allchar)
               ((_ re.capture 1) (re.+ (re.range "a" "z"))
               re.all)) x)
\end{minted}
%
extracts the left-most, longest sub-string consisting of only lower-case
characters from a string~$x$.

Our implementation is able to handle \textit{anchors} as well. Due to space restrictions we did not introduce them as part of our formalism. Basically, anchors are special symbols that match certain positions of a string without consuming any characters. In most practical programming languages, it is quite common to use \verb!^! and \verb!$! in regular expressions to signify the start and end of a string, respectively. We add \textsf{re.begin-anchor} and \textsf{re.end-anchor} for them.

\subsection{Implementation}

Our implementation revolves around PSSTs. Any of the three string operators mentioned above will be converted into an equivalent PSST (See Appendix~\ref{appendix:sec-extract-replace-to-psst}). {\ostrich} then iterates the dependency graph and repeatedly eliminates the them. More specifically, we first use Lemma \ref{lem:psst_preimage} to back-propagate regular constraints on string variables and check satisfiability, then use forward concrete evaluation to generate a model. 

\subsection{Experimental evaluation}

\begin{figure}[tb]
  \scriptsize

  \begin{minipage}{0.49\linewidth}
\begin{minted}{lisp}
(declare-fun x () String)
(define-fun  y () String
   (str.replace_cg_all x <re1> <repl>))
(push 1)
(assert (str.in.re x <re1>))
(assert (str.in.re y <re2>))
(check-sat) (get-model)
(pop 1) (push 1)
(assert (str.in.re x <regex>))
(assert (not (str.in.re y <re2>)))
(check-sat) (get-model)
(pop 1) (push 1)
(assert (not (str.in.re x <re1>)))
(check-sat) (get-model)
(pop 1)
\end{minted}
  \end{minipage}\hfill
  \raisebox{-19ex}{\rule{0.4pt}{39.5ex}}\hfill
  \begin{minipage}{0.49\linewidth}
\begin{minted}{js}
function fun(x) {
   if(/<re1>/.test(x)) {
      var y = x.replace(/<re1>/g, <repl>);
      if(/<re2>/.test(y))
        console.log("1");
      else
        console.log("2");
   }
   else
       console.log("3");
}

var S$ = require("S$");
var x = S$.symbol("x", "");
fun(x);
\end{minted}
  \end{minipage}
  
  \caption{Harnesses with replace-all: SMT-LIB for \ostrich,
    and JavaScript for \expose{}.}
  \label{fig:harness}
\end{figure}

\begin{table}[tb]
	\begin{center}
	\begin{tabular}{|l@{\quad}c@{\quad}|*{2}{c}|@{\quad}*{2}{c}|}
	\hline
	   & &
	  \multicolumn{2}{c|@{\quad}}{\textbf{\expose{}+Z3}} &\multicolumn{2}{c@{\quad}|}{\textbf{Aratha+\ostrich}}
	  \\
	   & \#JS-Progs. & ~ \# Executed~  & ~ \#Timeout~ &  ~\#Executed ~ & ~\#Timeout~
	  \\\hline
	  \textbf{\expose{}} & 94 & 93 & 1 & \textbf{94} & 0 
	  \\
	  && \multicolumn{2}{c|@{\quad}}{Average time: 17.65s} & \multicolumn{2}{c@{\quad}|}{Average time: \textbf{5.53}s}
	  \\\hline
	  \textbf{Match} & 38 &  30&   8& \textbf{38} & 0
	  \\
	  && \multicolumn{2}{c|@{\quad}}{Average time: 13.56s} & \multicolumn{2}{c@{\quad}|}{Average time: \textbf{2.78}s}
	  \\\hline
	  \textbf{Replace} & 40 & 16 & 24 & \textbf{40} & 0
	  \\
	  && \multicolumn{2}{c|@{\quad}}{Average time: 17.65s} & \multicolumn{2}{c@{\quad}|}{Average time: \textbf{2.69}s}
	  \\\hline
	\end{tabular}
	\end{center}
	\caption{Results of Expose+Z3 and Aratha+{\ostrich} on Javascript programs for \textbf{R1} and \textbf{R3}. All experiments were done on an Intel-Xeon-E5-2690-@2.90GHz machine, running 64-bit Linux and Java 1.8. Runtime was limited to 60s wall-clock time. Average time is wall-clock time.  \philipp{do average times include timeouts?}}
	\label{tab:exp-r1}

  \begin{center}
  \begin{tabular}{|l@{\quad}|*{6}{c}|*{5}{c}@{\quad}|}
    \hline
     & 
    \multicolumn{6}{c|}{\textbf{\ostrich}} &
    \multicolumn{5}{c|}{\textbf{\expose{}} on 73448}
    \\
      & \multicolumn{6}{c|}{\# queries solved within 60s}
      & \multicolumn{5}{c|}{\# paths covered within 60s}
    \\
     & ~~0~~ & ~~1~~ & ~~2~~ & ~~3~~ & ~~4~~ & ~~\#Err~~
     & ~~0~~ & ~~1~~ & ~~2~~ & ~~3~~ & ~~4~~
    \\\hline
    \textbf{Match}  & 75 & 20 & 77 & 167 & 96644 & 1132
    & 2497 & 7168 & 27685 & 36098 &
    \\
     \emph{(98117} & \multicolumn{6}{c|}{Average time: 0.79s}
    &\multicolumn{5}{c|}{Average time: 28.0s}
    \\
    \emph{benchm.)} & \multicolumn{6}{c|}{Total \#sat: 108132, \#unsat: 279135}
    & \multicolumn{5}{c|}{Total \#paths covered: 73448}
    \\\hline
    \textbf{Replace} & 445 & 229 & 576 & 95735 & --- & 1132
    & 3929 & 13859 & 51524 & 4217 & ---
    \\
    \emph{(98117} & \multicolumn{6}{c|}{Average time: 1.48s}
    & \multicolumn{5}{c|}{Average time: 55.0s}
    \\
    \emph{benchm.)} & \multicolumn{6}{c|}{Total \#sat: 273927, \#unsat: 14659}
    & \multicolumn{5}{c|}{Total \#paths covered: 73529}
      \\\hline
  \end{tabular}
  \end{center}
  \caption{The number of queries answered by \ostrich, and number of
    paths covered by \expose{}, in the \textbf{R2} experiments.  All
    experiments were done on an AMD Opteron 2220 SE machine, running
    64-bit Linux and Java~1.8.  Runtime per benchmark was limited to
    60s wall clock time, memory to 2GB, and the number of tests
    executed concurrently by \expose\ to 1.  Average time is
    wall-clock time needed per benchmark, and counts timeouts as 60s.}
  \label{tab:exp-r2}
\end{table}

Our experiments have the purpose of answering the following main questions:

\medskip
\noindent
\textbf{R1:} Are the  RWREs defined in this paper
suitable to encode regular expressions in programming languages,
for instance ECMAScript expressions~\cite{ECMAScript11}?
\\
\textbf{R2:} How does \ostrich\ compare to other solvers that can
handle real-world regular expressions, e.g., greedy/non-greedy
quantifiers and capturing groups?
\\
\textbf{R3:} How does \ostrich\ perform in the context of symbolic execution,
the prime application of string solving?

\paragraph{For \textbf{R1}:} We implemented a translator from ES11 regular
expressions to RWREs, and integrated \ostrich\ into the symbolic
execution tool Aratha~\cite{aratha}. We then ran Aratha+\ostrich\ on
the regression test suite of \expose{}~\cite{DBLP:conf/spin/LoringMK17},
as well as some other Javascript programs containing match or replace
functions extracted from Github. To verify the soundness of
Aratha+\ostrich, we compared the results with those produced by
\expose{}; we also checked the correctness of models computed by
\ostrich\ by concretely executing the JavaScript program under test on
the generated inputs, to confirm that the concrete execution indeed
follows the targeted path.\philipp{Zhilin, how should this formulation
  be weakened?} The results are summarized in Table~\ref{tab:exp-r1};
no inconsistencies were observed in the experiments, showing that the
semantics in this paper are indeed suitable for capturing ECMA
semantics.

\paragraph{For \textbf{R2}:} We are not aware of other constraint solvers
supporting capturing groups, neither among the SMT nor  the
CP solvers. %(e.g.,
%\cite{DBLP:conf/cpaior/ScottFPS17,DBLP:conf/cp/AmadiniGS20}).
The closest related work is the algorithm implemented in \expose{}, which
applies Z3-seq~\cite{Z3} for solving string constraints, but augments
it with a refinement loop to approximate RWRE
semantics.\footnote{We also considered to replace Z3 with \ostrich\ in
  \expose{} for the experiments. However, \expose{} integrates Z3 using its
  C API, and changing to a solver like \ostrich, with native support
  for capture groups, would have required the rewrite of substantial
  parts of \expose{}.}
%
For \textbf{R2}, we therefore compared \ostrich\ with \expose{} on 98117
regular expressions taken from \cite{DMC+19}.

For each of the regular expressions, we created four harnesses: two in
SMT-LIB, as input for \ostrich, and two in JavaScript, as input for
\expose{}. The two harnesses shown in Figure~\ref{fig:harness} use one of the
regular expressions from \cite{DMC+19} (\verb!<re1>!) in combination with
the replace-all function to simulate typical string processing;
\verb!<re2>! is the fixed pattern \verb![a-z]+!, and \verb!<repl>! the
replacement string \verb!"$1"!. The three paths of the JavaScript
function~\verb!fun! correspond to the three queries in the SMT-LIB
script, so that a direct comparison can be made between the results of
the SMT-LIB queries and the set of paths covered by \expose{}. The other
two harnesses are similar to the ones in Figure~\ref{fig:harness}, but
use the match function instead of replace-all, and contain four
queries and four paths, respectively.

The results of this experiment are shown in
Table~\ref{tab:exp-r2}. \ostrich\ is able to answer all four queries
in 96644 (98.5\%) of the match benchmarks, and all three queries in
95735 (97.6\%) of the replace-all benchmarks. The errors in 1132 cases are due
to back-references in \verb!<re1>!, which are not handled by \ostrich.
For match, the number of paths covered by \expose{} is comparable to
the number of \ostrich\ sat results, although the runtime of \expose{}
is on average 35x higher than that of \ostrich. For replace, the
runtime of \expose{} is even 37x higher, but the number of paths
covered is only 36\% of the number of sat answers produced by
\ostrich.  Overall, the experiments indicate that \ostrich\ is
significantly more efficient than the ExpoSE approach at solving path
constraints involving RWRE.

\paragraph{For \textbf{R3}:} We compare Aratha+\ostrich with \expose{}
on the same benchmarks as for \textbf{R1}.  From the results in
Table~\ref{tab:exp-r1}, we can see that, on average, Aratha+{\ostrich}
is faster than \expose{}+Z3 by a factor between 3 and 5, while being
able to cover more paths. The smaller speedup compared to the results
for \textbf{R2} can be explained by the fact that SMT-LIB queries
produced by Aratha are not pure string constraints, but also include
ADTs, arrays, and bit-vectors. The experiments still indicate that,
in the context of symbolic execution, {\ostrich} is significantly more
efficient than the CEGAR-augmented symbolic execution for dealing
with RWREs.
