%!TEX root = main.tex

\section{Implementation and Experiments}
\label{sect:impl}

We have implemented our decision procedure for $\strline$ in the SMT
solver \ostrich.\footnote{Name anonymized for doubly-blind review,
and will be provided in the final paper.}
%\cite{CHL+19}, %\url{https://github.com/uuverifiers/ostrich}}
%which provides a modular and easy-to-use framework for extending all
%sorts of string operations. 
As shown in Section \ref{sec:decision},
\PSST s satisfy the conditions required by the backwards reasoning
approach of \ostrich, which enables us to integrate our logic with
standard string theory. The resulting extended theory of strings is a
conservative extension of the SMT-LIB theory of Unicode
strings.\footnote{\url{http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml}}

\subsection{Input format}

Our implementation extends classical regular expression in SMT-LIB
with indexed {\sf re.capture} and {\sf re.reference} operators, which
denote capturing groups and references to them. We also add {\sf re.*?}
and {\sf re.+?} for non-greedy Kleene stars.

The three string operators that use these extended real world regular
expressions are {\sf str.replace\_cg}, {\sf str.replace\_cg\_all}, and
{\sf str.extract}. Operators {\sf str.replace\_cg} and {\sf
  str.replace\_cg\_all} are counterparts of the standard {\sf
  str.replace\_re} and {\sf replace\_re\_all} operators, and allow
capturing groups in the match pattern and references in the
replacement pattern. As an example, the following constraint swaps
lower-case characters~$x$ with a sub-sequent upper-case character~$Y$:
%
\begin{minted}{lisp}
  (= w (str.replace_cg_all v
                   (re.++ ((_ re.capture 1) (re.range "a" "z"))
                          ((_ re.capture 2) (re.range "A" "Z")))
                   (re.++ (_ re.reference 2) (_ re.reference 1))))
\end{minted}
%
The replacement string is written as a regular expression only
containing the operators {\sf re.++}, {\sf str.to\_re}, and {\sf
  re.reference}. It is not allowed to use symbolic variables as
replacement pattern, in contrast to the standard operators.

The indexed operator {\sf str.extract} implements $\extract_{i, e}$ in
$\strline$. For instance,
%
\begin{minted}{lisp}
  ((_ str.extract 1)
        (re.++ (re.*? re.allchar)
               ((_ re.capture 1) (re.* (re.range "a" "z"))
               re.all)) x)
\end{minted}
%
extracts the left-most, longest sub-string consisting of only lower-case
characters from a string~$x$.

Our implementation is able to handle \textit{anchors} as well. Due to space restrictions we did not introduce them as part of our formalism. Basically, anchors are special symbols that match certain positions of a string without consuming any characters. In most practical programming languages, it is quite common to use \verb!^! and \verb!$! in regular expressions to signify the start and end of a string, respectively. We add \textsf{re.begin-anchor} and \textsf{re.end-anchor} for them.

\subsection{Implementation}

Say more about the actual handling of PSSTs ...

\subsection{Experimental evaluation}

Our experiments have the purpose of answering two main questions:\\
\textbf{R1:} How does \ostrich\ compare to
other solvers
that can handle replace(All) and capturing groups?\\
\textbf{R2:} How does it perform in the context of symbolic execution,
the prime application of string solving?

Concerning \textbf{R1}, we are not aware of other SMT solvers with
support for capturing groups; the same holds for CP solvers (e.g.,
\cite{DBLP:conf/cpaior/ScottFPS17,DBLP:conf/cp/AmadiniGS20}). The
closest related work is the algorithm implemented in the symbolic
execution tool ExpoSE~\cite{DBLP:conf/spin/LoringMK17,LMK19}, which
applies Z3-seq~\cite{Z3} for solving string constraints, but augments
it with a refinement loop to approximate the semantics of
replace(All).\footnote{We also considered to replace Z3 with \ostrich\
  in ExpoSE for the experiments. However, ExpoSE integrates Z3 using
  its C API, and changing to a solver like \ostrich, with native
  support for capture groups, would have required the rewrite of
  substantial parts of ExpoSE.}
%
For \textbf{R1}, we therefore compared \ostrich\ with ExpoSE on
regular expressions taken from the ??? library.
