%!TEX root = main.tex

\section{Introduction}


% general intro on string constraint solving

%
%Strings are among the most important data types. 
The rise of programming 
languages like JavaScript, Python, Java, and PHP, which support a variety of
string operations (e.g. concatenation, regex matching, split, etc.), place
the string data types the forefront and make their use indispensable.
Despite this,
string-manipulating programs are notoriously subtle, error-prone, and their 
potential bugs
may bring severe security consequences. A typical example is cross-site
scripting (XSS), which is among the OWASP Top 10 Application Security Risks.
%Regular expressions are widely used in string-manipulating programs. 
An effective and increasingly popular method for identifying such bugs
in the program is symbolic execution, possibly in combination with dynamic
analysis. In a nutshell, this technique analyses a static path in a
a program under consideration, by viewing it as a constraint $\phi$, whose 
feasibility could be checked by an SMT-solver.

Regular expression matching is one of the most important string operations
in real-world programming languages \cite{Berkeley-JavaScript,BM17,LMK19,HAMPI}.
This is in fact also one reason that most state-of-the-art string solvers (e.g.
Z3, CVC4, Z3-str2, Norn, OSTRICH, ... \anthony{make sure we add all}) support
the so-called \emph{regular constraints}, e.g., matching a string with a 
regular expression, as we know it from formal language theory. Unfortunately, 
\emph{Real-world Regular Expressions} (RWRE) are dramatically different from 
\emph{classical Regular Expressions} (RE) from formal language theory. 
%In the sequel, we call the former as \emph{real-word} regular expressions and the latter as \emph{classical} regular expressions. 
Classical regular expressions are built from letters by the operators of concatenation, union, and repetition. Real-world regular expressions differ from classical ones mainly in the following two aspects: 1) the non-standard semantics of 
operators, e.g., the non-commutative union, the greedy repetition, 2) the new 
features, e.g., capturing groups and back references.

%The semantics of RWREs are tricky and can be different in different programming languages. 
%Real-world regular expressions are challenging for string constraint solvers. The state-of-the-art string constraint solvers e.g. CVC4 and Z3-str only support classical regular expressions. 
RWRE are in general more expressive than classical RE, e.g., it is known that
with backreferences one can easily generate languages that are not even 
context-free (e.g. see \cite{FS19}). %It is an open question whether 
Since the state-of-the-art string solvers support only classical RE instead of
RWREs, % are not primitively supported by state-of-the-art string solvers
%(in fact, they are in general ,
existing symbolic execution analysis approaches that handle real-world
string-manipulating programs with RWREs apply a workaround.
We mention here Aratha \cite{aratha} and Expose \cite{LMK19}, both of which are
symbolic execution engines for JavaScript programs.
%symbolic executors of string manipulating programs, e.g. 
Aratha performs a very rough approximation to the 
non-standard semantics of regular expressions, e.g., a backreference
is replaced by the regular expression referred to by the backreference 
operator. On the other hand, Expose attempts to exploit the power of string 
equations and classical REs (as implemented in Z3 \cite{Z3}) supported by string
solvers to capture the 
semantics of RWREs. Unfortunately, the semantics of RWREs cannot 
in general be captured by string constraints with REs. For this reason, 
Expose attempts to underapproximate the semantics of RWREs in the style of 
CEGAR (counter-example guided abstraction and refinement). This, however,
results in a rather severe price in both precision and performance. For one,
satisfiability of string equations with regular constraints is
well-known to be PSPACE-complete \cite{J16,Kozen77,P04}. For another, to the 
best of our knowledge, no existing string solver is complete for string 
equations with regular
constraints.
%\anthony{Say more
%here}

%In particular, 
 %to approach the genuine semantics of real-world regular expressions. 
%Although the CEGAR approach of Expose made a first step towards tackling the semantics of real-world regular expressions in the analysis and verification of string-manipulating programs, it is still unsatisfactory in both the precision and performance: 1) although CEGAR approximates the semantics of real-world regular expressions to a greater precision, it is still imprecise, 2) tens of refinement steps or even more are needed for simple string-manipulating programs containing regular expressions. Direct support of real-world regular expressions in string constraint solvers would facilitate the improvement of both the precision and scalability of symbolic executions of string manipulating programs.

\paragraph*{Contributions}
This paper proposes a novel approach to support real-world regular expressions in string constraint solving. The main idea of our approach is to propose a new automata model, called prioritized streaming string transducers (PSST). The model of PSST extends and combines prioritized finite transducers \cite{BM17} and streaming string transducers \cite{AC10,AD11}. With PSST, we encode the non-standard semantics of regular expression operators by priorities and deal with capturing groups and back references by string variables. 
The widely used string functions involving regular expressions, e.g. match and replace(all), can be easily transformed into PSSTs. 

We then design a decision procedure for a class of string constraints with real-world regular expressions. The decision procedure extends the backward reasoning approach proposed in \cite{CHL+19} to PSSTs. Specifically, we show that the pre-images of regular languages under PSSTs are regular and can be computed effectively. 

We implement the decision procedure on top of OSTRICH and do extensive experiments to evaluate the performance. For the benchmarks, we generate over 160,000 Javascript programs from a library of real-world regular expressions \cite{DMC+19}, by using some simple Javascript program template containing match and replace functions.  Then we generate all the path constraints for each Javascript program and put them into one smt file. We run OSTRICH on these smt files. The average running time on each file is 2 seconds. For comparison, we also run Expose on the Javascript programs. The average running time for each program is \zhilin{xxx} seconds. The huge difference of the running time shows that our approach can reason about real-world regular expressions in a much faster (and even more precise) way than the CEGAR based approach.


\paragraph*{Related work.}

theoretical study on regular expressions with capturing groups and back references \cite{CSY03,CN09,Freydenberger13,Schmid16,FS19}.

string constraint solving
\cite{ZAM19}


empirical study on regular expressions \cite{MDD+19}.

security issues around regular expressions, e.g. DDos attacks \cite{SP18,DCSL18}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
Strings are a fundamental data type in virtually all programming languages.
%Their generic nature can, however, lead to many subtle programming
%bugs, some with security consequences, e.g., cross-site scripting
%(XSS), which is among the OWASP Top 10 Application Security Risks
%\cite{owasp17}. 

One effective automatic testing method for identifying subtle programming errors  is based on \emph{symbolic execution}
\cite{king76} and combinations with dynamic analysis
called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
See \cite{symbex-survey} for an excellent survey. 

Unlike purely random testing,
which runs only \emph{concrete} program executions on different
inputs, the techniques of symbolic execution analyse \emph{static} paths
(also called symbolic executions) through the software system under test.
Such a path can be viewed as a constraint $\varphi$ (over
appropriate data domains) and the hope is that a fast
solver is available for checking the satisfiability of $\varphi$ (i.e. to check
the \emph{feasibility} of the static path), which can be used for generating
inputs that lead to certain parts of the program or an erroneous behaviour.
%a undesirable program behaviour.
%or an exploration of a new part of the
%system.


%
In this paper, we focus on two string operations with emphasis on practical usage of  regular expressions. Rather than textbook style regular expressions, regular expressions used in programming languages are considerably more involved. On particular feature we consider is the capturing group. This is particularly useful for string pattern matching 
%Many regular expression matching libraries perform matching as a form of parsing by using capturing groups,and thus 
where it can be returned what subexpression matched which substring. 

%This form of regular expression matching requires theoretical un-derpinnings different from classical regular expressions as defined in formal language theory. 


%which effective serves as a register when matching the regular expression to a string. Accompanying to the capturing groups 


%Many regular expression matching libraries perform matching as a form of parsing by using capturing groups,and thus output what subexpression matched which substring[9]. This form of regular expression matching requires theoretical un-derpinnings different from classical regular expressions as defined in formal language theory. 
%
%A popular implementation strategy used for performing regular expression matching (or parsing) with capturing groups, used for example in Java, .NET and the PCRE library[14], is a worst-case exponential time depth-first search strategy. A formal approach to matching with capturing groups can be obtained by using finite state transducers that output annotations on the input string to signify what subexpression matched which substring[16]. 
%
%A complicating factor in this approach is introduced by the fact that the matching semantics dictates a single output string for each input string, obtained by using rules to determine a “highest priority” match among the potentially exponentially many possible ones (in contrast,[6]discusses non-deterministic capturing groups).

The \emph{string-replace function}, 
which may be used to replace all occurrences of a string matching a pattern by 
another string. 

The replace function (especially 
the replace-all functionality) is omnipresent in HTML5 applications
\cite{LB16,TCJ16,YABI14}. 
%\mat{What does it mean for the replace function to be convincingly argued?}

A regular expression (shortened as regex) is a sequence of characters that define a search pattern. Usually such patterns are used by string-searching algorithms for "find" or "find and replace" operations on strings, or for input validation.  

The semantics of regular expressions with capturing groups and back references is rather involved. One of the reasons is that different languages may choose different semantics for a regex to match the string when the regex is served as a pattern. 

To capture the semantics, priority is introduced, giving rise to an extension of the standard finite-state automata. However, this is not sufficient for capturing string operations. For that purpose, we introduce  a new transducer model, prioritized streaming string transducer (PSST) which is a combination of priority which is essential for modelling capturing groups and streaming transducers which are a highly expressive formalism for modelling string operations. 
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
